---
title: "RNAseq_QC"
author: "Emma M Pfortmiller"
date: "2025-09-26"
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{css, echo=FALSE}
pre {
  max-height: 400px;
  overflow-y: auto;
}

pre[class] {
  max-height: 200px;
  
}
```

#Load Libraries
```{r Necessary Libraries, message=FALSE, warning=FALSE, include=FALSE}
library(tidyverse)
library(Biobase)
library(limma)
library(edgeR)
library(edgebundleR)
library(scales)
library(biomaRt)
library(ggrepel)
library(ggfortify)
library(corrplot)
library(readr)
library(org.Hs.eg.db)
library(AnnotationDbi)
library(ComplexHeatmap)
library(circlize)
library(grid)
library(reshape2)
library(ggVennDiagram)
library(UpSetR)
library(ggpubr)
library(VennDiagram)
library(VennDetail)
library(BiocParallel)
library(RUVSeq)
library(SummarizedExperiment)
library(ggsignif)
library(purrr)
library(rstatix)
library(ggrastr)
library(tibble)
library(grid)
library(eulerr)
library(patchwork)
library(car)
library(gprofiler2)
library(forcats)
library(broom)
library(magick)
```

#Define plot theme
```{r Custom Theme}
# Define the custom theme
# plot_theme_custom <- function() {
#   theme_minimal() +
#     theme(
#       #line for x and y axis
#       axis.line = element_line(linewidth = 1,
#                                color = "black"),
# 
#       #axis ticks only on x and y, length standard
#       axis.ticks.x = element_line(color = "black",
#                                 linewidth = 1),
#       axis.ticks.y = element_line(color = "black",
#                                 linewidth = 1),
#       axis.ticks.length = unit(0.05, "in"),
# 
#       #text and font
#       axis.text = element_text(color = "black",
#                                family = "Arial",
#                                size = 8),
#       axis.title = element_text(color = "black",
#                                 family = "Arial",
#                                 size = 10),
#       legend.text = element_text(color = "black",
#                                  family = "Arial",
#                                  size = 8),
#       legend.title = element_text(color = "black",
#                                   family = "Arial",
#                                   size = 10),
#       plot.title = element_text(color = "black",
#                                 family = "Arial",
#                                 size = 12),
# 
#       #blank background and border
#       panel.background = element_blank(),
#       panel.border = element_blank(),
# 
#       #gridlines for alignment
#       panel.grid.major = element_line(color = "grey80", linewidth = 0.5),  #grey major grid for align in illus
#       panel.grid.minor = element_line(color = "grey90", linewidth = 0.5) #grey minor grid for align in illus
#     )
# }

# saveRDS(plot_theme_custom, "data/plot_theme_custom.RDS")

theme_custom <- readRDS("data/plot_theme_custom.RDS")

```

#Define saving plots as pdfs
```{r pdf saving function}

save_plot <- function(plot, filename, 
                      folder = ".", 
                      width = 8, 
                      height = 6, 
                      units = "in", 
                      dpi = 300, 
                      add_date = TRUE) {
  if (missing(filename)) stop("Please provide a filename (without extension) for the plot.")

  date_str <- if (add_date) paste0("_", format(Sys.Date(), "%y%m%d")) else ""
  pdf_file <- file.path(folder, paste0(filename, date_str, ".pdf"))
  png_file <- file.path(folder, paste0(filename, date_str, ".png"))
  ggsave(filename = pdf_file, plot = plot, device = cairo_pdf, width = width, height = height, units = units, bg = "transparent")
  ggsave(filename = png_file, plot = plot, device = "png", width = width, height = height, units = units, dpi = dpi, bg = "transparent")
  message("Saved plot as Cairo PDF: ", pdf_file)
  message("Saved plot as PNG: ", png_file)
}

output_folder <- "C:/Users/emmap/OneDrive/Desktop/Ward Lab/Experiments/Stressor Project/Full Set RNAseq/plots"


#save plot function created
#to use: just define the plot name, filename_base, width, height
```

#Factors and Colors
```{r Theme Colors and Factors}
#each of these to be used after pairwise comparison save individual

####STIMULI####
# stim_list <- list(
#   "Tunicamycin" = "TUN",
#   "Thapsigargin" = "THA",
#   "Doxorubicin" = "DOX",
#   "Nutlin-3" = "NUTL",
#   "Lipopolysaccharides" = "LPS",
#   "Tumor Necrosis Factor alpha" = "TNFa",
#   "Bisphenol A" = "BPA",
#   "Perfluorooctanoic Acid" = "PFOA"
# )
# stimuli_vec <- unlist(lapply(names(stim_list), function(cat) {
#   setNames(rep(cat, length(stim_list[[cat]])), stim_list[[cat]])
# }))
# saveRDS(stimuli_vec, "data/theme/stimuli_fullname_vector.RDS")
stim_vec <- readRDS("data/theme/stimuli_fullname_vector.RDS")

####RESPONSE CATEGORY####
# resp_list <- list(
#   UPR = c("TUN", "THA"),
#   DDR = c("DOX", "NUTL"),
#   IMR = c("LPS", "TNFa"),
#   MMR = c("BPA", "PFOA")
# )
# response_vec <- unlist(lapply(names(resp_list), function(cat) {
#   setNames(rep(cat, length(resp_list[[cat]])), resp_list[[cat]])
# }))
# saveRDS(response_vec, "data/theme/response_categories_vector.RDS")
response_vec <- readRDS("data/theme/response_categories_vector.RDS")

####SPECIES####
# spec_list <- list(
#   Human = "H",
#   Chimp = "C"
# )
# species_vec <- unlist(lapply(names(spec_list), function(cat) {
#   setNames(rep(cat, length(spec_list[[cat]])), spec_list[[cat]])
# }))
# saveRDS(species_vec, "data/theme/species_vector.RDS")
species_vec <- readRDS("data/theme/species_vector.RDS")

####TIME####
# time_list <- list(
#   "2hr" = "2",
#   "24hr" = "24"
# )
# time_vec <- unlist(lapply(names(time_list), function(cat) {
#   setNames(rep(cat, length(time_list[[cat]])), time_list[[cat]])
# }))
# saveRDS(time_vec, "data/theme/time_vector.RDS")
time_vec <- readRDS("data/theme/time_vector.RDS")

####INDIVIDUAL####
# ind_list <- list(
#   H24280 = "H1",
#   H28126 = "H2",
#   "84-1" = "H3",
#   H21792 = "H4",
#   H20682 = "H5",
#   H22422 = "H6",
#   "78-1" = "H7",
#   C3647 = "C1",
#   C8861 = "C2",
#   C4020 = "C3",
#   C3649 = "C4",
#   C3651 = "C5",
#   C40280 = "C6",
#   C4955 = "C7"
# )
# ind_vec <- unlist(lapply(names(ind_list), function (cat) {
#   setNames(rep(cat, length(ind_list[[cat]])), ind_list[[cat]])
# }))
# saveRDS(ind_vec, "data/theme/individual_vector.RDS")
ind_vec <- readRDS("data/theme/individual_vector.RDS")

```


#Datasets Creation
```{r Import Counts Tables}
#I have one counts table for chimpanzee and another for human

#read in chimpanzee counts
# c_raw_counts <- read_csv("C:/Users/emmap/OneDrive/Desktop/Ward Lab/Experiments/Stressor Project/Full Set RNAseq/featurecounts/c_samples_counts_fin.csv")

# saveRDS(c_raw_counts, "data/counts/c_raw_counts.RDS")

c_raw_counts <- readRDS("data/counts/c_raw_counts.RDS")

#read in human counts table in the same manner

# h_raw_counts <- read_csv("C:/Users/emmap/OneDrive/Desktop/Ward Lab/Experiments/Stressor Project/Full Set RNAseq/featurecounts/h_samples_counts_fin.csv")

# saveRDS(h_raw_counts, "data/counts/h_raw_counts.RDS")

h_raw_counts <- readRDS("data/counts/h_raw_counts.RDS")

```

#Metadata
```{r Read in Metadata Sheet}
#I have a metadata sheet so I can associate the column names with their sample ID

# metadata <- read_csv("C:/Users/emmap/OneDrive/Desktop/Ward Lab/Experiments/Stressor Project/Full Set RNAseq/featurecounts/dissrt_metadata.csv",
#     col_types = cols(Conc = col_number()))

#save metadata sheet

# saveRDS(metadata, "data/counts/dissrt_metadata.RDS")

metadata <- readRDS("data/counts/dissrt_metadata.RDS")

#subset my metadata 
human_metadata <- metadata[metadata$Species == "H", ]
chimp_metadata <- metadata[metadata$Species == "C", ]

```

```{r Change Column Names}
#I want to modify the column names for each dataset to match their sample id and treatment instead of library id

#first make sure that Geneid changes to Ensembl_ID
# rename_with_metadata <- function(counts, metadata_subset) {
# #
#   # 1. Rename first column to Ensembl_ID if not already
#   colnames(counts)[1] <- "Ensembl_ID"
# 
#   # 2. Columns to rename (all except first)
#   cols_to_rename <- colnames(counts)[-1]
# 
#   # 3. Remove ".sorted.bam" from column names
#   library_names <- gsub("\\.sorted\\.bam$", "", cols_to_rename)
# 
#   # 4. Match library names to Sample_name in metadata
#   new_names <- metadata_subset$Sample_Tx[match(library_names, metadata_subset$Sample_ID)]
# 
#   # 5. Warn if any columns didnâ€™t match
#   unmatched <- cols_to_rename[is.na(new_names)]
#   if (length(unmatched) > 0) {
#     warning("The following library names did not match metadata: ", paste(unmatched, collapse = ", "))
#   }
# 
#   # 6. Replace column names (keep first column as Ensembl_ID)
#   colnames(counts) <- c("Ensembl_ID", ifelse(is.na(new_names), cols_to_rename, new_names))
# 
#   return(counts)
# }

# Subset metadata by species
# human_metadata <- metadata[metadata$Species == "H", ]
# chimp_metadata <- metadata[metadata$Species == "C", ]

# Apply to counts tables
# h_counts <- rename_with_metadata(h_raw_counts, human_metadata)
# c_counts <- rename_with_metadata(c_raw_counts, chimp_metadata)

# save new counts files that have correctly named columns
# saveRDS(h_counts, "data/counts/h_counts.RDS")
# saveRDS(c_counts, "data/counts/c_counts.RDS")

#kept all of this for posterity but don't need to run again

#read in final files
h_counts <- readRDS("data/counts/h_counts.RDS")
c_counts <- readRDS("data/counts/c_counts.RDS")

```

#Combine my datasets
```{r Join my Human and Chimp datasets together}
#make sure to sort them so that all of the genes match up
# 
# h_counts <- h_counts[order(h_counts$Ensembl_ID), ]
# c_counts <- c_counts[order(c_counts$Ensembl_ID), ]
# 
# hc_counts <- left_join(c_counts, h_counts, by = "Ensembl_ID")

#now save my combined counts table with both species
# saveRDS(hc_counts, "data/counts/combined_counts_table_h_c.RDS")

# hc_counts <- readRDS("data/counts/combined_counts_table_h_c.RDS")

#now I have a combined dataframe with the treatment names included

####Replace hc_counts with one made below that has Entrez_ID instead of Ensembl_ID

hc_counts <- readRDS("data/counts/hc_counts_entrez.RDS")

```

#QC Mapping/fC
```{r Mapping and Counts Stats}
#read in my excel file with all of this information
# map_align_stats <- read_excel("C:/Users/emmap/OneDrive/Desktop/Ward Lab/Experiments/Stressor Project/Full Set RNAseq/featurecounts/Mapping_Alignment_Stats_Dissrt_EMP_250930.xlsx",
#     sheet = "Map_Align_all", col_types = c("text",
#         "text", "skip", "text", "text", "text",
#         "text", "numeric", "text", "text",
#         "numeric", "text", "skip", "text",
#         "skip", "text", "skip", "text", "text",
#         "text", "numeric", "numeric", "numeric",
#         "numeric", "numeric", "numeric",
#         "numeric", "numeric", "numeric",
#         "numeric", "numeric", "numeric",
#         "numeric", "numeric", "numeric",
#         "numeric", "numeric", "numeric"))
# View(map_align_stats)

#save as a csv for later
# saveRDS(map_align_stats, "data/counts/mapping_alignment_stats_sheet.RDS")
# write.csv(map_align_stats, "data/counts/mapping_alignment_stats_sheet.csv")

map_align_stats <- readRDS("data/counts/mapping_alignment_stats_sheet.RDS")

#now I want to do some QC plots to highlight this information

Individual <- as.character(map_align_stats$Ind)
Species <- as.character(map_align_stats$Species)
Time <- as.character(map_align_stats$Time_Num)
Stimulus <- as.character(map_align_stats$Stimulus)

ind_col <- setNames(rainbow(length(unique(Individual))), unique(Individual))



time_col <- c("2" = "#392344",
              "24" = "#457291")

species_col <- c("H" = "#E56473",
                 "C" = "#EE4902")

####Reads by Sample####
reads_by_sample <- c(
  "TUN" = "#E41A1C",
  "THA" = "#377EB8", 
  "DOX" = "#4DAF4A", 
  "NUTL" = "#984EA3", 
  "DMSO" = "#999999", 
  "LPS" = "#FFFF33", 
  "TNFa" = "#FC8D62", 
  "H2O" = "#777777", 
  "BPA" = "#F781BF", 
  "PFOA" = "#66C2A5", 
  "EtOH" = "#AAAAAA"
)

map_align_stats$Stimulus <- factor(
  map_align_stats$Stimulus,
  levels = c("TUN", "THA", "DOX", "NUTL", "DMSO", 
             "LPS", "TNFa", "H2O", "BPA", "PFOA", "EtOH")
)

map_align_stats$Ind <- factor(
  map_align_stats$Ind,
  levels = c("H1", "H2", "H3", "H4", "H5", 
             "H6", "H7", "C1", "C2", "C3", 
             "C4", "C5", "C6", "C7")
)

#Total Reads per Sample
total_reads_sample_plot <- map_align_stats %>% 
  ggplot(., aes (x = Sample_Tx, y = Total_Reads_Paired, 
                 fill = Stimulus, 
                 group_by = Sample_Tx))+
  geom_col()+
 scale_fill_manual(values=reads_by_sample)+
  ggtitle(expression("Total reads by sample"))+
  xlab("")+
  ylab(expression("RNA-sequencing reads"))+
  theme_bw()+
  theme(plot.title = element_text(size = rel(2), hjust = 0.5),
        axis.title = element_text(size = 15, color = "black"),
        axis.ticks = element_line(linewidth = 1.5),
        axis.text.y = element_text(size =10, color = "black", angle = 0, hjust = 0.8, vjust = 0.5),
        axis.text.x = element_text(size =10, color = "black", angle = 90, hjust = 1, vjust = 0.2),
        #strip.text.x = element_text(size = 15, color = "black", face = "bold"),
        strip.text.y = element_text(color = "white"))

#Total Mapped Reads per Sample
map_reads_sample_plot <- map_align_stats %>% 
  ggplot(., aes (x = Sample_Tx, y = Mapped_Paired, 
                 fill = Stimulus, 
                 group_by = Sample_Tx))+
  geom_col()+
 # geom_hline(aes(yintercept=20000000))+
 scale_fill_manual(values=reads_by_sample)+
  ggtitle(expression("Mapped reads by sample"))+
  xlab("")+
  ylab(expression("RNA-sequencing reads"))+
  theme_bw()+
  theme(plot.title = element_text(size = rel(2), hjust = 0.5),
        axis.title = element_text(size = 15, color = "black"),
        axis.ticks = element_line(linewidth = 1.5),
        axis.text.y = element_text(size =10, color = "black", angle = 0, hjust = 0.8, vjust = 0.5),
        axis.text.x = element_text(size =10, color = "black", angle = 90, hjust = 1, vjust = 0.2),
        #strip.text.x = element_text(size = 15, color = "black", face = "bold"),
        strip.text.y = element_text(color = "white"))

####Total Reads by Sample Boxplot####
total_reads_sample_boxplot <- map_align_stats %>% 
  ggplot(., aes (x = Sample_Tx, y= Total_Reads_Paired, fill = Stimulus))+
  geom_boxplot()+
 scale_fill_manual(values=reads_by_sample)+
  ggtitle(expression("Total reads by sample"))+
  xlab("")+
  ylab(expression("RNA-sequencing reads"))+
  theme_bw()+
  theme(plot.title = element_text(size = rel(2), hjust = 0.5),
        axis.title = element_text(size = 15, color = "black"),
        axis.ticks = element_line(linewidth = 1.5),
        axis.text.y = element_text(size =10, color = "black", angle = 0, hjust = 0.8, vjust = 0.5),
        axis.text.x = element_text(size =10, color = "black", angle = 90, hjust = 1, vjust = 0.2),
        #strip.text.x = element_text(size = 15, color = "black", face = "bold"),
        strip.text.y = element_text(color = "white"))

####Total Mapped Reads by Sample Boxplot####
map_reads_sample_boxplot <- map_align_stats %>% 
  ggplot(., aes (x = Sample_Tx, y= Mapped_Paired, fill = Stimulus))+
  geom_boxplot()+
 scale_fill_manual(values=reads_by_sample)+
  ggtitle(expression("Mapped reads by sample"))+
  xlab("")+
  ylab(expression("RNA-sequencing reads"))+
  theme_bw()+
  theme(plot.title = element_text(size = rel(2), hjust = 0.5),
        axis.title = element_text(size = 15, color = "black"),
        axis.ticks = element_line(linewidth = 1.5),
        axis.text.y = element_text(size =10, color = "black", angle = 0, hjust = 0.8, vjust = 0.5),
        axis.text.x = element_text(size =10, color = "black", angle = 90, hjust = 1, vjust = 0.2),
        #strip.text.x = element_text(size = 15, color = "black", face = "bold"),
        strip.text.y = element_text(color = "white"))


####Total Reads by Stimulus####
total_reads_stimulus_plot <- map_align_stats %>% 
  ggplot(., aes (x = Stimulus, y= Total_Reads_Paired, fill = Stimulus))+
  geom_boxplot()+
 scale_fill_manual(values=reads_by_sample)+
  ggtitle(expression("Total reads by stimulus"))+
  xlab("")+
  ylab(expression("RNA-sequencing reads"))+
  theme_bw()+
  theme(plot.title = element_text(size = rel(2), hjust = 0.5),
        axis.title = element_text(size = 15, color = "black"),
        axis.ticks = element_line(linewidth = 1.5),
        axis.text.y = element_text(size =10, color = "black", angle = 0, hjust = 0.8, vjust = 0.5),
        axis.text.x = element_text(size =10, color = "black", angle = 90, hjust = 1, vjust = 0.2),
        #strip.text.x = element_text(size = 15, color = "black", face = "bold"),
        strip.text.y = element_text(color = "white"))

####Mapped Reads by Stimulus####
map_reads_stimulus_plot <- map_align_stats %>% 
  ggplot(., aes (x = Stimulus, y= Mapped_Paired, fill = Stimulus))+
  geom_boxplot()+
 scale_fill_manual(values=reads_by_sample)+
  ggtitle(expression("Mapped reads by stimulus"))+
  xlab("")+
  ylab(expression("RNA-sequencing reads"))+
  theme_bw()+
  theme(plot.title = element_text(size = rel(2), hjust = 0.5),
        axis.title = element_text(size = 15, color = "black"),
        axis.ticks = element_line(linewidth = 1.5),
        axis.text.y = element_text(size =10, color = "black", angle = 0, hjust = 0.8, vjust = 0.5),
        axis.text.x = element_text(size =10, color = "black", angle = 90, hjust = 1, vjust = 0.2),
        #strip.text.x = element_text(size = 15, color = "black", face = "bold"),
        strip.text.y = element_text(color = "white"))


####Total Reads Per Individual####
total_reads_ind_plot <- map_align_stats %>% 
  ggplot(., aes (x =as.factor(Ind), y = Total_Reads_Paired))+
  geom_boxplot(aes(fill= Ind))+
 scale_fill_manual(values = ind_col)+
  ggtitle(expression("Total reads by individual"))+
  xlab("")+
  ylab(expression("RNA-sequencing reads"))+
  theme_bw()+

  theme(plot.title = element_text(size = rel(2), hjust = 0.5),
        axis.title = element_text(size = 15, color = "black"),
        axis.ticks = element_line(linewidth = 1.5),
        axis.text.y = element_text(size =10, color = "black", angle = 0, hjust = 0.8, vjust = 0.5),
        axis.text.x = element_text(size =10, color = "black", angle = 0, hjust = 1),
        #strip.text.x = element_text(size = 15, color = "black", face = "bold"),
        strip.text.y = element_text(color = "white"))

####Total Mapped Reads Per Individual####
map_reads_ind_plot <- map_align_stats %>% 
  ggplot(., aes (x =as.factor(Ind), y = Mapped_Paired))+
  geom_boxplot(aes(fill=Ind))+
 scale_fill_manual(values = c(ind_col))+
  ggtitle(expression("Mapped reads by individual"))+
  xlab("")+
  ylab(expression("RNA-sequencing reads"))+
  theme_bw()+

  theme(plot.title = element_text(size = rel(2), hjust = 0.5),
        axis.title = element_text(size = 15, color = "black"),
        axis.ticks = element_line(linewidth = 1.5),
        axis.text.y = element_text(size =10, color = "black", angle = 0, hjust = 0.8, vjust = 0.5),
        axis.text.x = element_text(size =10, color = "black", angle = 0, hjust = 1),
        #strip.text.x = element_text(size = 15, color = "black", face = "bold"),
        strip.text.y = element_text(color = "white"))


####Total Reads Per Timepoint####
map_align_stats$Time_Num <- factor(map_align_stats$Time_Num, 
                            levels = c("2", "24"))

reads_by_time <- c("2" = "#392344", "24" = "#457291")

total_reads_time_plot <- map_align_stats %>% 
  ggplot(., aes (x = Sample_ID, y = Total_Reads_Paired, fill = Time_Num, group_by = Ind))+
  geom_col()+
 # geom_hline(aes(yintercept=20000000))+
 scale_fill_manual(values = reads_by_time)+
  ggtitle(expression("Total reads by timepoint"))+
  xlab("")+
  ylab(expression("RNA-sequencing reads"))+
  theme_bw()+
  theme(plot.title = element_text(size = rel(2), hjust = 0.5),
        axis.title = element_text(size = 15, color = "black"),
        axis.ticks = element_line(linewidth = 1.5),
        axis.text.y = element_text(size =10, color = "black", angle = 0, hjust = 0.8, vjust = 0.5),
        axis.text.x = element_text(size =10, color = "black", angle = 90, hjust = 1, vjust = 0.2),
        #strip.text.x = element_text(size = 15, color = "black", face = "bold"),
        strip.text.y = element_text(color = "white"))

####Mapped Reads Per Timepoint####
map_reads_time_plot <- map_align_stats %>% 
  ggplot(., aes (x = Sample_ID, y = Mapped_Paired, fill = Time_Num, group_by = Ind))+
  geom_col()+
 # geom_hline(aes(yintercept=20000000))+
 scale_fill_manual(values = reads_by_time)+
  ggtitle(expression("Mapped reads by timepoint"))+
  xlab("")+
  ylab(expression("RNA-sequencing reads"))+
  theme_bw()+
  theme(plot.title = element_text(size = rel(2), hjust = 0.5),
        axis.title = element_text(size = 15, color = "black"),
        axis.ticks = element_line(linewidth = 1.5),
        axis.text.y = element_text(size =10, color = "black", angle = 0, hjust = 0.8, vjust = 0.5),
        axis.text.x = element_text(size =10, color = "black", angle = 90, hjust = 1, vjust = 0.2),
        #strip.text.x = element_text(size = 15, color = "black", face = "bold"),
        strip.text.y = element_text(color = "white"))



####Total Reads Per Timepoint Boxplot####
total_reads_time_boxplot <- map_align_stats %>% 
  ggplot(., aes (x = Time_Num, y= Total_Reads_Paired, fill = Time_Num))+
  geom_boxplot()+
 scale_fill_manual(values=reads_by_time)+
  ggtitle(expression("Total reads by timepoint"))+
  xlab("")+
  ylab(expression("RNA-sequencing reads"))+
  theme_bw()+
  theme(plot.title = element_text(size = rel(2), hjust = 0.5),
        axis.title = element_text(size = 15, color = "black"),
        axis.ticks = element_line(linewidth = 1.5),
        axis.text.y = element_text(size =10, color = "black", angle = 0, hjust = 0.8, vjust = 0.5),
        axis.text.x = element_text(size =10, color = "black", angle = 90, hjust = 1, vjust = 0.2),
        #strip.text.x = element_text(size = 15, color = "black", face = "bold"),
        strip.text.y = element_text(color = "white"))

####Total Mapped Reads Per Timepoint####
map_reads_time_boxplot <- map_align_stats %>% 
  ggplot(., aes (x = Time_Num, y= Mapped_Paired, fill = Time_Num))+
  geom_boxplot()+
 scale_fill_manual(values=reads_by_time)+
  ggtitle(expression("Mapped reads by timepoint"))+
  xlab("")+
  ylab(expression("RNA-sequencing reads"))+
  theme_bw()+
  theme(plot.title = element_text(size = rel(2), hjust = 0.5),
        axis.title = element_text(size = 15, color = "black"),
        axis.ticks = element_line(linewidth = 1.5),
        axis.text.y = element_text(size =10, color = "black", angle = 0, hjust = 0.8, vjust = 0.5),
        axis.text.x = element_text(size =10, color = "black", angle = 90, hjust = 1, vjust = 0.2),
        #strip.text.x = element_text(size = 15, color = "black", face = "bold"),
        strip.text.y = element_text(color = "white"))


####Total Reads Per Species####
reads_by_species <- c("H" = "#E56473", "C" = "#EE4902")
total_reads_species_plot <- map_align_stats %>% 
  ggplot(., aes (x = Ind, y = Total_Reads_Paired, fill = Species, group_by = Ind))+
  geom_col()+
 scale_fill_manual(values=reads_by_species)+
  ggtitle(expression("Total reads by species"))+
  xlab("")+
  ylab(expression("RNA-sequencing reads"))+
  theme_bw()+
  theme(plot.title = element_text(size = rel(2), hjust = 0.5),
        axis.title = element_text(size = 15, color = "black"),
        axis.ticks = element_line(linewidth = 1.5),
        axis.text.y = element_text(size =10, color = "black", angle = 0, hjust = 0.8, vjust = 0.5),
        axis.text.x = element_text(size =10, color = "black", angle = 90, hjust = 1, vjust = 0.2),
        #strip.text.x = element_text(size = 15, color = "black", face = "bold"),
        strip.text.y = element_text(color = "white"))

####Total Mapped Reads by Species####
total_reads_species_boxplot <- map_align_stats %>% 
  ggplot(., aes (x = Ind, y= Total_Reads_Paired, fill = Species))+
  geom_boxplot()+
 scale_fill_manual(values=reads_by_species)+
  ggtitle(expression("Total reads by species"))+
  xlab("")+
  ylab(expression("RNA-sequencing reads"))+
  theme_bw()+
  theme(plot.title = element_text(size = rel(2), hjust = 0.5),
        axis.title = element_text(size = 15, color = "black"),
        axis.ticks = element_line(linewidth = 1.5),
        axis.text.y = element_text(size =10, color = "black", angle = 0, hjust = 0.8, vjust = 0.5),
        axis.text.x = element_text(size =10, color = "black", angle = 90, hjust = 1, vjust = 0.2),
        #strip.text.x = element_text(size = 15, color = "black", face = "bold"),
        strip.text.y = element_text(color = "white"))

####Total Mapped Reads by Species####
map_reads_species_plot <- map_align_stats %>% 
  ggplot(., aes (x = Ind, y= Mapped_Paired, fill = Species))+
  geom_boxplot()+
 scale_fill_manual(values=reads_by_species)+
  ggtitle(expression("Mapped reads by species"))+
  xlab("")+
  ylab(expression("RNA-sequencing reads"))+
  theme_bw()+
  theme(plot.title = element_text(size = rel(2), hjust = 0.5),
        axis.title = element_text(size = 15, color = "black"),
        axis.ticks = element_line(linewidth = 1.5),
        axis.text.y = element_text(size =10, color = "black", angle = 0, hjust = 0.8, vjust = 0.5),
        axis.text.x = element_text(size =10, color = "black", angle = 90, hjust = 1, vjust = 0.2),
        #strip.text.x = element_text(size = 15, color = "black", face = "bold"),
        strip.text.y = element_text(color = "white"))

#make a list so I can save all of these plots
qc_map_plots_list <- list(
  total_reads_sample_plot,
  map_reads_sample_plot,
  total_reads_sample_boxplot,
  map_reads_sample_boxplot,
  total_reads_ind_plot,
  map_reads_ind_plot,
  total_reads_species_plot,
  total_reads_species_boxplot,
  map_reads_species_plot,
  total_reads_stimulus_plot,
  map_reads_stimulus_plot,
  total_reads_time_plot,
  total_reads_time_boxplot,
  map_reads_time_plot,
  map_reads_time_boxplot
)

qc_map_plots_names <- list(
  "total_reads_sample",
  "map_reads_sample",
  "total_reads_sample_boxplot",
  "map_reads_sample_boxplot",
  "total_reads_ind",
  "map_reads_ind",
  "total_reads_species",
  "total_reads_species_boxplot",
  "map_reads_species",
  "total_reads_stimulus",
  "map_reads_stimulus",
  "total_reads_time_plot",
  "total_reads_time_boxplot",
  "map_reads_time_plot",
  "map_reads_time_boxplot"
)

qc_map_plots_names <- paste0(qc_map_plots_names, "_EMP")


# stopifnot(length(qc_map_plots_list) == length(qc_map_plots_names))

#save all of these plots to my designated folder

for (i in seq_along(qc_map_plots_list)) {
  save_plot(
    plot = qc_map_plots_list[[i]],
    filename = qc_map_plots_names[i],
    folder = output_folder
  )
}

```

###QC Boxplots featureCounts
```{r featureCounts Stats}

#Total Counts per Sample
map_align_stats %>% 
  ggplot(., aes (x = Sample_Tx, y = Total_Counts, 
                 fill = Stimulus, 
                 group_by = Sample_Tx))+
  geom_col()+
 # geom_hline(aes(yintercept=20000000))+
 scale_fill_manual(values=reads_by_sample)+
  ggtitle(expression("Total number of counts by sample"))+
  xlab("")+
  ylab(expression("fC Counts"))+
  theme_bw()+
  theme(plot.title = element_text(size = rel(2), hjust = 0.5),
        axis.title = element_text(size = 15, color = "black"),
        axis.ticks = element_line(linewidth = 1.5),
        axis.text.y = element_text(size =10, color = "black", angle = 0, hjust = 0.8, vjust = 0.5),
        axis.text.x = element_text(size =10, color = "black", angle = 90, hjust = 1, vjust = 0.2),
        strip.text.y = element_text(color = "white"))

#Total Assigned Counts per Sample
map_align_stats %>% 
  ggplot(., aes (x = Sample_Tx, y = Assigned, 
                 fill = Stimulus, 
                 group_by = Sample_Tx))+
  geom_col()+
 scale_fill_manual(values=reads_by_sample)+
  ggtitle(expression("Total number of assigned counts by sample"))+
  xlab("")+
  ylab(expression("fC Counts"))+
  theme_bw()+
  theme(plot.title = element_text(size = rel(2), hjust = 0.5),
        axis.title = element_text(size = 15, color = "black"),
        axis.ticks = element_line(linewidth = 1.5),
        axis.text.y = element_text(size =10, color = "black", angle = 0, hjust = 0.8, vjust = 0.5),
        axis.text.x = element_text(size =10, color = "black", angle = 90, hjust = 1, vjust = 0.2),
        #strip.text.x = element_text(size = 15, color = "black", face = "bold"),
        strip.text.y = element_text(color = "white"))

####Total Counts by Sample Boxplot####
map_align_stats %>% 
  ggplot(., aes (x = Sample_Tx, y= Total_Counts, fill = Stimulus))+
  geom_boxplot()+
 scale_fill_manual(values=reads_by_sample)+
  ggtitle(expression("Total number of counts by sample"))+
  xlab("")+
  ylab(expression("fC Counts"))+
  theme_bw()+
  theme(plot.title = element_text(size = rel(2), hjust = 0.5),
        axis.title = element_text(size = 15, color = "black"),
        axis.ticks = element_line(linewidth = 1.5),
        axis.text.y = element_text(size =10, color = "black", angle = 0, hjust = 0.8, vjust = 0.5),
        axis.text.x = element_text(size =10, color = "black", angle = 90, hjust = 1, vjust = 0.2),
        #strip.text.x = element_text(size = 15, color = "black", face = "bold"),
        strip.text.y = element_text(color = "white"))

####Total Assigned Counts by Sample Boxplot####
map_align_stats %>% 
  ggplot(., aes (x = Sample_Tx, y= Assigned, fill = Stimulus))+
  geom_boxplot()+
 scale_fill_manual(values=reads_by_sample)+
  ggtitle(expression("Total number of assigned counts by sample"))+
  xlab("")+
  ylab(expression("fC Counts"))+
  theme_bw()+
  theme(plot.title = element_text(size = rel(2), hjust = 0.5),
        axis.title = element_text(size = 15, color = "black"),
        axis.ticks = element_line(linewidth = 1.5),
        axis.text.y = element_text(size =10, color = "black", angle = 0, hjust = 0.8, vjust = 0.5),
        axis.text.x = element_text(size =10, color = "black", angle = 90, hjust = 1, vjust = 0.2),
        #strip.text.x = element_text(size = 15, color = "black", face = "bold"),
        strip.text.y = element_text(color = "white"))


####Total Counts by Stimulus####
map_align_stats %>% 
  ggplot(., aes (x = Stimulus, y= Total_Counts, fill = Stimulus))+
  geom_boxplot()+
 scale_fill_manual(values=reads_by_sample)+
  ggtitle(expression("Total number of counts by stimulus"))+
  xlab("")+
  ylab(expression("fC Counts"))+
  theme_bw()+
  theme(plot.title = element_text(size = rel(2), hjust = 0.5),
        axis.title = element_text(size = 15, color = "black"),
        axis.ticks = element_line(linewidth = 1.5),
        axis.text.y = element_text(size =10, color = "black", angle = 0, hjust = 0.8, vjust = 0.5),
        axis.text.x = element_text(size =10, color = "black", angle = 90, hjust = 1, vjust = 0.2),
        #strip.text.x = element_text(size = 15, color = "black", face = "bold"),
        strip.text.y = element_text(color = "white"))

####Total Assigned Counts by Stimulus####
map_align_stats %>% 
  ggplot(., aes (x = Stimulus, y= Assigned, fill = Stimulus))+
  geom_boxplot()+
 scale_fill_manual(values=reads_by_sample)+
  ggtitle(expression("Total number of assigned counts by stimulus"))+
  xlab("")+
  ylab(expression("fC Counts"))+
  theme_bw()+
  theme(plot.title = element_text(size = rel(2), hjust = 0.5),
        axis.title = element_text(size = 15, color = "black"),
        axis.ticks = element_line(linewidth = 1.5),
        axis.text.y = element_text(size =10, color = "black", angle = 0, hjust = 0.8, vjust = 0.5),
        axis.text.x = element_text(size =10, color = "black", angle = 90, hjust = 1, vjust = 0.2),
        #strip.text.x = element_text(size = 15, color = "black", face = "bold"),
        strip.text.y = element_text(color = "white"))


####Total Counts Per Individual####
map_align_stats %>% 
  ggplot(., aes (x =as.factor(Line), y = Total_Counts))+
  geom_boxplot(aes(fill= Ind))+
 scale_fill_manual(values = ind_col)+
  ggtitle(expression("Total number of counts by individual"))+
  xlab("")+
  ylab(expression("fC Counts"))+
  theme_bw()+

  theme(plot.title = element_text(size = rel(2), hjust = 0.5),
        axis.title = element_text(size = 15, color = "black"),
        axis.ticks = element_line(linewidth = 1.5),
        axis.text.y = element_text(size =10, color = "black", angle = 0, hjust = 0.8, vjust = 0.5),
        axis.text.x = element_text(size =10, color = "black", angle = 0, hjust = 1),
        #strip.text.x = element_text(size = 15, color = "black", face = "bold"),
        strip.text.y = element_text(color = "white"))

####Total Assigned Counts Per Individual####
map_align_stats %>% 
  ggplot(., aes (x =as.factor(Line), y = Assigned))+
  geom_boxplot(aes(fill=Ind))+
 scale_fill_manual(values = c(ind_col))+
  ggtitle(expression("Total number of assigned counts by individual"))+
  xlab("")+
  ylab(expression("fC Counts"))+
  theme_bw()+

  theme(plot.title = element_text(size = rel(2), hjust = 0.5),
        axis.title = element_text(size = 15, color = "black"),
        axis.ticks = element_line(linewidth = 1.5),
        axis.text.y = element_text(size =10, color = "black", angle = 0, hjust = 0.8, vjust = 0.5),
        axis.text.x = element_text(size =10, color = "black", angle = 0, hjust = 1),
        #strip.text.x = element_text(size = 15, color = "black", face = "bold"),
        strip.text.y = element_text(color = "white"))


####Total Counts Per Timepoint####
map_align_stats$Time <- factor(map_align_stats$Time, 
                            levels = c("2", "24"))

reads_by_time <- c("2" = "#392344", "24" = "#457291")

map_align_stats %>% 
  ggplot(., aes (x = Sample_ID, y = Total_Counts, fill = Time, group_by = Ind))+
  geom_col()+
 scale_fill_manual(values = reads_by_time)+
  ggtitle(expression("Total number of counts by timepoint"))+
  xlab("")+
  ylab(expression("fC Counts"))+
  theme_bw()+
  theme(plot.title = element_text(size = rel(2), hjust = 0.5),
        axis.title = element_text(size = 15, color = "black"),
        axis.ticks = element_line(linewidth = 1.5),
        axis.text.y = element_text(size =10, color = "black", angle = 0, hjust = 0.8, vjust = 0.5),
        axis.text.x = element_text(size =10, color = "black", angle = 90, hjust = 1, vjust = 0.2),
        #strip.text.x = element_text(size = 15, color = "black", face = "bold"),
        strip.text.y = element_text(color = "white"))


####Total Assigned Counts Per Timepoint####
map_align_stats %>% 
  ggplot(., aes (x = Time, y= Assigned, fill = Time))+
  geom_boxplot()+
 scale_fill_manual(values=reads_by_time)+
  ggtitle(expression("Total number of assigned counts by timepoint"))+
  xlab("")+
  ylab(expression("fC Counts"))+
  theme_bw()+
  
  theme(plot.title = element_text(size = rel(2), hjust = 0.5),
        axis.title = element_text(size = 15, color = "black"),
        axis.ticks = element_line(linewidth = 1.5),
        axis.text.y = element_text(size =10, color = "black", angle = 0, hjust = 0.8, vjust = 0.5),
        axis.text.x = element_text(size =10, color = "black", angle = 90, hjust = 1, vjust = 0.2),
        #strip.text.x = element_text(size = 15, color = "black", face = "bold"),
        strip.text.y = element_text(color = "white"))


####Total Counts Per Species####
reads_by_species <- c("C" = "#E56473", "H" = "#EE4902")
map_align_stats %>% 
  ggplot(., aes (x = Line, y = Total_Counts, fill = Species, group_by = Line))+
  geom_col()+
 scale_fill_manual(values=reads_by_species)+
  ggtitle(expression("Total number of counts by species"))+
  xlab("")+
  ylab(expression("fC Counts"))+
  theme_bw()+
  theme(plot.title = element_text(size = rel(2), hjust = 0.5),
        axis.title = element_text(size = 15, color = "black"),
        axis.ticks = element_line(linewidth = 1.5),
        axis.text.y = element_text(size =10, color = "black", angle = 0, hjust = 0.8, vjust = 0.5),
        axis.text.x = element_text(size =10, color = "black", angle = 90, hjust = 1, vjust = 0.2),
        #strip.text.x = element_text(size = 15, color = "black", face = "bold"),
        strip.text.y = element_text(color = "white"))


####Total Assign Counts by Species####
map_align_stats %>% 
  ggplot(., aes (x = Line, y= Assigned, fill = Species))+
  geom_boxplot()+
 scale_fill_manual(values=reads_by_species)+
  ggtitle(expression("Total number of assigned counts by species"))+
  xlab("")+
  ylab(expression("fC Counts"))+
  theme_bw()+
  theme(plot.title = element_text(size = rel(2), hjust = 0.5),
        axis.title = element_text(size = 15, color = "black"),
        axis.ticks = element_line(linewidth = 1.5),
        axis.text.y = element_text(size =10, color = "black", angle = 0, hjust = 0.8, vjust = 0.5),
        axis.text.x = element_text(size =10, color = "black", angle = 90, hjust = 1, vjust = 0.2),
        #strip.text.x = element_text(size = 15, color = "black", face = "bold"),
        strip.text.y = element_text(color = "white"))


```


#Filter Dataframe
```{r Filter with rowMeans}
#first, convert to log2cpm

#ensure that Entrez_ID are the rownames

hc_cpm_unfilt <- cpm(hc_counts, log = TRUE)
dim(hc_cpm_unfilt)
#28802 genes of 307 columns as expected

hist(hc_cpm_unfilt,
     main = "Unfiltered cpm",
     xlab = expression("log"[2]*"cpm"),
     col = 4)

#now filter by rowMeans > 0 to exclude lowly expressed genes
hc_cpm_matrix <- subset(hc_cpm_unfilt, (rowMeans(hc_cpm_unfilt) > 0))
dim(hc_cpm_matrix)
#13661 genes after filtering

#save this as an RDS and csv
# saveRDS(hc_cpm_matrix, "data/counts/hc_cpm_filtered_matrix.RDS")
# write.csv(hc_cpm_matrix, "data/counts/hc_cpm_filtered_matrix.csv")

hc_cpm_matrix <- readRDS("data/counts/hc_cpm_filtered_matrix.RDS")

#plot this out to show the filtering
hist(hc_cpm_matrix, 
     main = "Filtered Counts (cpm) rowMeans > 0",
     xlab = expression("log"[2]*"cpm"),
     col = 2)

```




#QC Boxplots
```{r QC Boxplots for H and C}
#make boxplots of all counts vs log2cpm filtered counts

par(mar = c(8,4,2,2))
#boxplot of unfiltered cpm matrix
hc_cpm_unfilt_boxplot <- boxplot(hc_cpm_unfilt, 
        main = "Unfiltered log2cpm", 
        names = colnames(hc_cpm_unfilt), 
        adj=1, las = 2, cex.axis = 0.7)

#set the margins so the x axis isn't cut off
par(mar = c(8,4,2,2))
#boxplot of filtered cpm matrix
hc_cpm_filt_boxplot <- boxplot(hc_cpm_matrix, 
        main = "Filtered log2cpm (rowMeans > 0)", 
        names = colnames(hc_cpm_matrix), 
        adj=1, las = 2, cex.axis = 0.7)


```



#Convert Ensembl to Entrez
```{r converting ensembl id into entrez id}
# ensembl_ids <- rownames(hc_cpm_matrix)
# ensembl_ids_unfilt <- rownames(hc_counts)

# entrez_ids_unfilt <- mapIds(
#   org.Hs.eg.db,
#   keys = ensembl_ids_unfilt,
#   column = "ENTREZID",
#   keytype = "ENSEMBL",
#   multiVals = "first"
# )

#since there was many mapping, check which ones are duplicated
# sum(duplicated(entrez_ids_unfilt))
#1701 are duplicated with entrez id

#convert to df
# hc_cpm_df <- as.data.frame(hc_cpm_matrix)
# hc_counts_df <- as.data.frame(hc_counts)

#add the Entrez_ID column to my counts dataframe
# hc_counts_df <- hc_counts_df %>%
#   dplyr::mutate(Entrez_ID = entrez_ids_unfilt)

#move it to the front so I can see it easily against Ensembl_ID
# hc_counts_df <- hc_counts_df %>%
#   dplyr::select(Entrez_ID, everything())

#now keep only unique values
# hc_counts_df <- hc_counts_df %>%
#   group_by(Entrez_ID) %>%
#   summarise(across(where(is.numeric), \(x) sum(x, na.rm = TRUE))) %>%
#   ungroup()

#remove any NA genes
# hc_counts_df <- hc_counts_df[!is.na(hc_counts_df$Entrez_ID), ]
# dim(hc_counts_df)
#this gives me a total of 13619 genes, which is within the range I desired
#when done for counts it gives me 28802 genes

#now make the rownames Entrez_ID
# hc_counts_df <- column_to_rownames(hc_counts_df, var = "Entrez_ID")

#save entrez_id version of dataframe
# saveRDS(hc_counts_df, "data/counts/hc_counts_entrez_dataframe.RDS")
# write.csv(hc_counts_df, "data/counts/hc_counts_entrez_dataframe.csv")

#read in data
hc_cpm_df <- readRDS("data/counts/hc_cpm_filt_entrez_dataframe.RDS")
hc_cpm_df_unfilt <- readRDS("data/counts/hc_cpm_unfilt_entrez_dataframe.RDS")
hc_counts_df <- readRDS("data/counts/hc_counts_entrez_dataframe.RDS")

# hc_counts <- hc_counts_df

# saveRDS(hc_counts, "data/counts/hc_counts_entrez.RDS")
# now move this above to where I was making cpm lists so I have entrez id instead
```

```{r PCA Plots}

prcomp_hc_unfilt <- prcomp(t(hc_cpm_unfilt), center =  TRUE)

prcomp_hc_filt <- prcomp(t(hc_cpm_matrix), center =  TRUE)

#read in my metadata annotations
metadata <- readRDS("data/counts/dissrt_metadata.RDS")

#add in labels for individual numbers
ind_num <- metadata$Ind_Num

drug_col <- readRDS("data/theme/stimulus_color_palette_all.RDS")

metadata$Time <- factor(metadata$Time)

metadata$Drug <- factor(
  metadata$Drug,
  levels = c("TUN", "THA", "DOX", "NUTL", "DMSO", 
             "LPS", "TNFa", "H2O", "BPA", "PFOA", "EtOH")
)

#now plot my PCA for unfiltered log2cpm
####PC1/PC2####
unfilt_PC1_PC2 <- ggplot2::autoplot(prcomp_hc_unfilt, data = metadata, colour = "Drug", shape = "Time", size =4, x=1, y=2) +
  ggrepel::geom_text_repel(label=ind_num,
                           vjust = -.5,
                           max.overlaps = 100,
                           segment.color = "grey",
                           segment.size = 0.1) +
  scale_color_manual(values=drug_col) +
  ggtitle(expression("Unfiltered log"[2]*"cpm PC1/PC2")) +
  theme_custom()


####PC2/PC3####
unfilt_PC2_PC3 <- ggplot2::autoplot(prcomp_hc_unfilt, data = metadata, colour = "Drug", shape = "Time", size =4, x=2, y=3) +
  ggrepel::geom_text_repel(label=ind_num,
                           vjust = -.5,
                           max.overlaps = 100,
                           segment.color = "grey",
                           segment.size = 0.1) +
  scale_color_manual(values=drug_col) +
  ggtitle(expression("Unfiltered log"[2]*"cpm PC2/PC3")) +
  theme_custom()

####PC3/PC4####
unfilt_PC3_PC4 <- ggplot2::autoplot(prcomp_hc_unfilt, data = metadata, colour = "Drug", shape = "Time", size =4, x=3, y=4) +
  ggrepel::geom_text_repel(label=ind_num, 
                           vjust = -.5, 
                           max.overlaps = 100,
                           segment.color = "grey",
                           segment.size = 0.1) +
  scale_color_manual(values=drug_col) +
  ggtitle(expression("Unfiltered log"[2]*"cpm PC3/PC4")) +
  theme_custom()


#Now plot my PCA for filtered log2cpm
####PC1/PC2####
filt_PC1_PC2 <- ggplot2::autoplot(prcomp_hc_filt, data = metadata, colour = "Drug", shape = "Time", size =4, x=1, y=2) +
  ggrepel::geom_text_repel(label=ind_num, 
                           vjust = -.5, 
                           max.overlaps = 100,
                           segment.color = "grey",
                           segment.size = 0.1) +
  scale_color_manual(values=drug_col) +
  ggtitle(expression("Filtered log"[2]*"cpm PC1/PC2")) +
  theme_custom()

####PC2/PC3####
filt_PC2_PC3 <- ggplot2::autoplot(prcomp_hc_filt, data = metadata, colour = "Drug", shape = "Time", size =4, x=2, y=3) +
  ggrepel::geom_text_repel(label=ind_num, 
                           vjust = -.5, 
                           max.overlaps = 100,
                           segment.color = "grey",
                           segment.size = 0.1) +
  scale_color_manual(values=drug_col) +
  ggtitle(expression("Filtered log"[2]*"cpm PC2/PC3")) +
  theme_custom()

####PC3/PC4####
filt_PC3_PC4 <- ggplot2::autoplot(prcomp_hc_filt, data = metadata, colour = "Drug", shape = "Time", size =4, x=3, y=4) +
  ggrepel::geom_text_repel(label=ind_num, 
                           vjust = -.5, 
                           max.overlaps = 100,
                           segment.color = "grey",
                           segment.size = 0.1) +
  scale_color_manual(values=drug_col) +
  ggtitle(expression("Filtered log"[2]*"cpm PC2/PC3")) +
  theme_custom()

#now save all of these together in pdf and png
hc_pca_plots <- list(
  unfilt_PC1_PC2 = unfilt_PC1_PC2,
  unfilt_PC2_PC3 = unfilt_PC2_PC3,
  unfilt_PC3_PC4 = unfilt_PC3_PC4,
  filt_PC1_PC2 = filt_PC1_PC2,
  filt_PC2_PC3 = filt_PC2_PC3,
  filt_PC3_PC4 = filt_PC3_PC4
)

print(hc_pca_plots)

# for (plot_name in names(hc_pca_plots)) {
#   save_plot(
#     plot = hc_pca_plots[[plot_name]],
#     filename = paste0("PCA_HC_", plot_name, "_EMP"),
#     folder = output_folder
#   )
# }

```

##PCA 24hr
```{r PCA Plots 24hr Only}
#now filter out all of the 2hr points and plot your filtered PCA plots

#read in my metadata annotations
metadata <- readRDS("data/counts/dissrt_metadata.RDS")

metadata_24 <- metadata %>% 
  dplyr::filter(Time == "24")

#now make my matrices into only 24hr samples
hc_cpm_unfilt_24 <- hc_cpm_unfilt[, metadata_24$Sample_Tx, drop = FALSE]
hc_cpm_mat_24 <- hc_cpm_matrix[, metadata_24$Sample_Tx, drop = FALSE]
# saveRDS(hc_cpm_mat_24, "data/counts/hc_filtered_cpm_matrix_24hr.RDS")

#prcomp transformation
prcomp_hc_unfilt_24 <- prcomp(t(hc_cpm_unfilt_24), center = TRUE)
prcomp_hc_filt_24 <- prcomp(t(hc_cpm_mat_24), center =  TRUE)

#add in labels for individual numbers
ind_num <- metadata_24$Ind_Num
drug_col <- readRDS("data/theme/stimulus_color_palette_all.RDS")

metadata_24$Drug <- factor(
  metadata_24$Drug,
  levels = c("TUN", "THA", "DOX", "NUTL", "DMSO", 
             "LPS", "TNFa", "H2O", "BPA", "PFOA", "EtOH")
)

metadata_24$Species <- factor(
  metadata_24$Species, 
  levels = c("H", "C")
)

#now plot my PCA for unfiltered/filtered log2cpm
####PC1/PC2####
unfilt24_PC1_PC2 <- ggplot2::autoplot(prcomp_hc_unfilt_24, 
                                    data = metadata_24, 
                                    colour = "Drug", 
                                    shape = "Species", 
                                    size =4, x=1, y=2) +
  ggrepel::geom_text_repel(label=ind_num,
                           vjust = -.5,
                           max.overlaps = 50,
                           segment.color = "grey",
                           segment.size = 0.1) +
  scale_color_manual(values=drug_col) +
  ggtitle(expression("log"[2]*"cpm PC1/PC2 24hr (unfilt)")) +
  theme_custom()


filt24_PC1_PC2 <- ggplot2::autoplot(prcomp_hc_filt_24, 
                                    data = metadata_24, 
                                    colour = "Drug", 
                                    shape = "Species", 
                                    size =3, x=1, y=2) +
  # ggrepel::geom_text_repel(label=ind_num,
  #                          vjust = -.5,
  #                          max.overlaps = 50,
  #                          segment.color = "grey",
  #                          segment.size = 0.1) +
  scale_color_manual(values=drug_col) +
  ggtitle(expression("log"[2]*"cpm PC1/PC2 24hr")) +
  theme_custom()

####PC2/3####
unfilt24_PC2_PC3 <- ggplot2::autoplot(prcomp_hc_unfilt_24, 
                                    data = metadata_24, 
                                    colour = "Drug", 
                                    shape = "Species", 
                                    size =4, x=2, y=3) +
  ggrepel::geom_text_repel(label=ind_num,
                           vjust = -.5,
                           max.overlaps = 50,
                           segment.color = "grey",
                           segment.size = 0.1) +
  scale_color_manual(values=drug_col) +
  ggtitle(expression("log"[2]*"cpm PC2/PC3 24hr (unfilt)")) +
  theme_custom()


filt24_PC2_PC3 <- ggplot2::autoplot(prcomp_hc_filt_24, 
                                    data = metadata_24, 
                                    colour = "Drug", 
                                    shape = "Species", 
                                    size =4, x=2, y=3) +
  ggrepel::geom_text_repel(label=ind_num,
                           vjust = -.5,
                           max.overlaps = 50,
                           segment.color = "grey",
                           segment.size = 0.1) +
  scale_color_manual(values=drug_col) +
  ggtitle(expression("log"[2]*"cpm PC2/PC3 24hr")) +
  theme_custom()

####PC3/4####
unfilt24_PC3_PC4 <- ggplot2::autoplot(prcomp_hc_unfilt_24, 
                                    data = metadata_24, 
                                    colour = "Drug", 
                                    shape = "Species", 
                                    size =4, x=3, y=4) +
  ggrepel::geom_text_repel(label=ind_num,
                           vjust = -.5,
                           max.overlaps = 50,
                           segment.color = "grey",
                           segment.size = 0.1) +
  scale_color_manual(values=drug_col) +
  ggtitle(expression("log"[2]*"cpm PC3/PC4 24hr (unfilt)")) +
  theme_custom()


filt24_PC3_PC4 <- ggplot2::autoplot(prcomp_hc_filt_24, 
                                    data = metadata_24, 
                                    colour = "Drug", 
                                    shape = "Species", 
                                    size =4, x=3, y=4) +
  ggrepel::geom_text_repel(label=ind_num,
                           vjust = -.5,
                           max.overlaps = 50,
                           segment.color = "grey",
                           segment.size = 0.1) +
  scale_color_manual(values=drug_col) +
  ggtitle(expression("log"[2]*"cpm PC3/PC4 24hr")) +
  theme_custom()

#make a list of your 24hr PCA plots and print them all

pca_24_list <- list(
  unfilt24_PC1_PC2 = unfilt24_PC1_PC2,
  unfilt24_PC2_PC3 = unfilt24_PC2_PC3,
  unfilt24_PC3_PC4 = unfilt24_PC3_PC4,
  filt24_PC1_PC2 = filt24_PC1_PC2,
  filt24_PC2_PC3 = filt24_PC2_PC3,
  filt24_PC3_PC4 = filt24_PC3_PC4
)

print(pca_24_list)

# for (plot_name in names(pca_24_list)) {
#   save_plot(
#     plot = pca_24_list[[plot_name]],
#     filename = paste0("PCA_24hr_HC_", plot_name, "_EMP"),
#     folder = output_folder
#   )
# }

save_plot(
  plot = filt2_PC1_PC2,
  filename = "PCA_2hr_HC_filt2_PC1_PC2_EMP",
  folder = output_folder
)


```


```{r 2hr PCA Plots}
metadata <- readRDS("data/counts/dissrt_metadata.RDS")

metadata_2hr <- metadata %>% 
  dplyr::filter(Time == "2")

#now make my matrices into only 24hr samples
hc_cpm_unfilt_2 <- hc_cpm_unfilt[, metadata_2hr$Sample_Tx, drop = FALSE]
hc_cpm_mat_2 <- hc_cpm_matrix[, metadata_2hr$Sample_Tx, drop = FALSE]
# saveRDS(hc_cpm_mat_24, "data/counts/hc_filtered_cpm_matrix_24hr.RDS")

#prcomp transformation
prcomp_hc_unfilt_2 <- prcomp(t(hc_cpm_unfilt_2), center = TRUE)
prcomp_hc_filt_2 <- prcomp(t(hc_cpm_mat_2), center =  TRUE)

#add in labels for individual numbers
ind_num <- metadata_2hr$Ind_Num
drug_col <- readRDS("data/theme/stimulus_color_palette_all.RDS")

metadata_2hr$Drug <- factor(
  metadata_2hr$Drug,
  levels = c("TUN", "THA", "DOX", "NUTL", "DMSO", 
             "LPS", "TNFa", "H2O", "BPA", "PFOA", "EtOH")
)

metadata_2hr$Species <- factor(
  metadata_2hr$Species, 
  levels = c("H", "C")
)

#now plot my PCA for unfiltered/filtered log2cpm
####PC1/PC2####
unfilt2_PC1_PC2 <- ggplot2::autoplot(prcomp_hc_unfilt_2, 
                                    data = metadata_2hr, 
                                    colour = "Drug", 
                                    shape = "Species", 
                                    size =4, x=1, y=2) +
  ggrepel::geom_text_repel(label=ind_num,
                           vjust = -.5,
                           max.overlaps = 50,
                           segment.color = "grey",
                           segment.size = 0.1) +
  scale_color_manual(values=drug_col) +
  ggtitle(expression("log"[2]*"cpm PC1/PC2 2hr (unfilt)")) +
  theme_custom()


filt2_PC1_PC2 <- ggplot2::autoplot(prcomp_hc_filt_2, 
                                    data = metadata_2hr, 
                                    colour = "Drug", 
                                    shape = "Species", 
                                    size =3, x=1, y=2) +
  ggrepel::geom_text_repel(label=ind_num,
                           vjust = -.5,
                           max.overlaps = 50,
                           segment.color = "grey",
                           segment.size = 0.1) +
  scale_color_manual(values=drug_col) +
  ggtitle(expression("log"[2]*"cpm PC1/PC2 2hr")) +
  theme_custom()

####PC2/3####
unfilt2_PC2_PC3 <- ggplot2::autoplot(prcomp_hc_unfilt_2, 
                                    data = metadata_2hr, 
                                    colour = "Drug", 
                                    shape = "Species", 
                                    size =4, x=2, y=3) +
  ggrepel::geom_text_repel(label=ind_num,
                           vjust = -.5,
                           max.overlaps = 50,
                           segment.color = "grey",
                           segment.size = 0.1) +
  scale_color_manual(values=drug_col) +
  ggtitle(expression("log"[2]*"cpm PC2/PC3 2hr (unfilt)")) +
  theme_custom()


filt2_PC2_PC3 <- ggplot2::autoplot(prcomp_hc_filt_2, 
                                    data = metadata_2hr, 
                                    colour = "Drug", 
                                    shape = "Species", 
                                    size =4, x=2, y=3) +
  ggrepel::geom_text_repel(label=ind_num,
                           vjust = -.5,
                           max.overlaps = 50,
                           segment.color = "grey",
                           segment.size = 0.1) +
  scale_color_manual(values=drug_col) +
  ggtitle(expression("log"[2]*"cpm PC2/PC3 2hr")) +
  theme_custom()

####PC3/4####
unfilt2_PC3_PC4 <- ggplot2::autoplot(prcomp_hc_unfilt_2, 
                                    data = metadata_2hr, 
                                    colour = "Drug", 
                                    shape = "Species", 
                                    size =4, x=3, y=4) +
  ggrepel::geom_text_repel(label=ind_num,
                           vjust = -.5,
                           max.overlaps = 50,
                           segment.color = "grey",
                           segment.size = 0.1) +
  scale_color_manual(values=drug_col) +
  ggtitle(expression("log"[2]*"cpm PC3/PC4 2hr (unfilt)")) +
  theme_custom()


filt2_PC3_PC4 <- ggplot2::autoplot(prcomp_hc_filt_2, 
                                    data = metadata_2hr, 
                                    colour = "Drug", 
                                    shape = "Species", 
                                    size =4, x=3, y=4) +
  ggrepel::geom_text_repel(label=ind_num,
                           vjust = -.5,
                           max.overlaps = 50,
                           segment.color = "grey",
                           segment.size = 0.1) +
  scale_color_manual(values=drug_col) +
  ggtitle(expression("log"[2]*"cpm PC3/PC4 2hr")) +
  theme_custom()

#make a list of your 2hr PCA plots and print them all

pca_2_list <- list(
  unfilt2_PC1_PC2 = unfilt2_PC1_PC2,
  unfilt2_PC2_PC3 = unfilt2_PC2_PC3,
  unfilt2_PC3_PC4 = unfilt2_PC3_PC4,
  filt2_PC1_PC2 = filt2_PC1_PC2,
  filt2_PC2_PC3 = filt2_PC2_PC3,
  filt2_PC3_PC4 = filt2_PC3_PC4
)

print(pca_2_list)

for (plot_name in names(pca_2_list)) {
  save_plot(
    plot = pca_2_list[[plot_name]],
    filename = paste0("PCA_2hr_HC_", plot_name, "_EMP"),
    folder = output_folder
  )
}


```


#Subset PCA
```{r PCA of Subsets}
#UPR Subset
upr_tx <- c("TUN", "THA", "DMSO")
upr_meta <- metadata %>% 
  dplyr::filter(Drug %in% upr_tx)
upr_cpm <- hc_cpm_df[, colnames(hc_cpm_df) %in% upr_meta$Sample_Tx] 
upr_cols <- c(
  "TUN" = "#E41A1C",
  "THA" = "#377EB8", 
  "DMSO" = "#999999"
)

#DDR Subset
ddr_tx <- c("DOX", "NUTL", "DMSO")
ddr_meta <- metadata %>% 
  dplyr::filter(Drug %in% ddr_tx)
ddr_cpm <- hc_cpm_df[, colnames(hc_cpm_df) %in% ddr_meta$Sample_Tx]  
ddr_cols <- c(
  "DOX" = "#4DAF4A", 
  "NUTL" = "#984EA3",
  "DMSO" = "#999999")

#IMR Subset
imr_tx <- c("LPS", "TNFa", "H2O")
imr_meta <- metadata %>% 
  dplyr::filter(Drug %in% imr_tx)
imr_cpm <- hc_cpm_df[, colnames(hc_cpm_df) %in% imr_meta$Sample_Tx]  
imr_cols <-  c(
  "LPS" = "#FFFF33", 
  "TNFa" = "#FC8D62", 
  "H2O" = "#777777")

#MMR Subset
mmr_tx <- c("BPA", "PFOA", "EtOH")
mmr_meta <- metadata %>% 
  dplyr::filter(Drug %in% mmr_tx)
mmr_cpm <- hc_cpm_df[, colnames(hc_cpm_df) %in% mmr_meta$Sample_Tx]  
mmr_cols <- c(
  "BPA" = "#F781BF", 
  "PFOA" = "#66C2A5", 
  "EtOH" = "#AAAAAA")

#now make a function to plot these PCA plots in subsets
make_pca_plots <- function(subset_name, subset_drugs, hc_matrix, metadata, ind_num, drug_col) {
  # filter metadata
  keep_idx <- metadata$Drug %in% subset_drugs
  metadata_sub <- metadata[keep_idx, ]
  ind_sub <- ind_num[keep_idx]
  
  # subset expression matrix to same samples
  hc_matrix_sub <- hc_matrix[, keep_idx]
  
  # run PCA on subset
  prcomp_sub <- prcomp(t(hc_matrix_sub), scale. = TRUE)
  
  ## PC1/PC2
  p1 <- autoplot(prcomp_sub, data = metadata_sub,
                 colour = "Drug", shape = "Time", size = 4,
                 x = 1, y = 2) +
    geom_text_repel(label = ind_sub,
                    vjust = -.5,
                    max.overlaps = 100,
                    segment.color = "grey",
                    segment.size = 0.1) +
    scale_color_manual(values = drug_col) +
    ggtitle(bquote(.(subset_name) ~ "subset: Filtered log"[2] * "cpm PC1/PC2")) +
    theme_custom()
  
  ## PC2/PC3
  p2 <- autoplot(prcomp_sub, data = metadata_sub,
                 colour = "Drug", shape = "Time", size = 4,
                 x = 2, y = 3) +
    geom_text_repel(label = ind_sub,
                    vjust = -.5,
                    max.overlaps = 100,
                    segment.color = "grey",
                    segment.size = 0.1) +
    scale_color_manual(values = drug_col) +
    ggtitle(bquote(.(subset_name) ~ "subset: Filtered log"[2] * "cpm PC2/PC3")) +
    theme_custom()
  
  list(p1 = p1, p2 = p2)
}

# ---- Run for each subset ----
upr_plots <- make_pca_plots("UPR", c("TUN", "THA", "DMSO"), hc_cpm_matrix, metadata, ind_num, drug_col)
ddr_plots <- make_pca_plots("DDR", c("DOX", "NUTL", "DMSO"), hc_cpm_matrix, metadata, ind_num, drug_col)
imr_plots <- make_pca_plots("IMR", c("LPS", "TNFa", "H2O"), hc_cpm_matrix, metadata, ind_num, drug_col)
mmr_plots <- make_pca_plots("MMR", c("BPA", "PFOA", "EtOH"), hc_cpm_matrix, metadata, ind_num, drug_col)

all_plots_subset_pca <- list(
  upr_PC1_PC2 = upr_plots$p1,
  upr_PC2_PC3 = upr_plots$p2,
  ddr_PC1_PC2 = ddr_plots$p1,
  ddr_PC2_PC3 = ddr_plots$p2,
  imr_PC1_PC2 = imr_plots$p1,
  imr_PC2_PC3 = imr_plots$p2,
  mmr_PC1_PC2 = mmr_plots$p1,
  mmr_PC2_PC3 = mmr_plots$p2
)

print(all_plots_subset_pca)

# # Loop through each plot and save
# for (plot_name in names(all_plots_subset_pca)) {
#   save_plot(
#     plot = all_plots_subset_pca[[plot_name]],
#     filename = paste0("Subset_PCA_", plot_name, "_EMP"),
#     folder = output_folder
#     )
# }


```

##24hr Subset PCA
```{r Subset PCA plots 24hr only}
#now do the same thing you did above but filter out any 2hr samples

#make matrices into only 24hr samples
hc_cpm_mat_24 <- hc_cpm_matrix[, metadata_24$Sample_Tx, drop = FALSE]

#UPR Subset
upr_tx <- c("TUN", "THA", "DMSO")
upr_meta_24 <- metadata_24 %>% 
  dplyr::filter(Drug %in% upr_tx)
upr_cpm_24 <- hc_cpm_mat_24[, colnames(hc_cpm_mat_24) %in% upr_meta_24$Sample_Tx] 

#DDR Subset
ddr_tx <- c("DOX", "NUTL", "DMSO")
ddr_meta_24 <- metadata_24 %>% 
  dplyr::filter(Drug %in% ddr_tx)
ddr_cpm_24 <- hc_cpm_mat_24[, colnames(hc_cpm_mat_24) %in% ddr_meta_24$Sample_Tx]  

#IMR Subset
imr_tx <- c("LPS", "TNFa", "H2O")
imr_meta_24 <- metadata_24 %>% 
  dplyr::filter(Drug %in% imr_tx)
imr_cpm_24 <- hc_cpm_mat_24[, colnames(hc_cpm_mat_24) %in% imr_meta_24$Sample_Tx]  

#MMR Subset
mmr_tx <- c("BPA", "PFOA", "EtOH")
mmr_meta_24 <- metadata_24 %>% 
  dplyr::filter(Drug %in% mmr_tx)
mmr_cpm_24 <- hc_cpm_mat_24[, colnames(hc_cpm_mat_24) %in% mmr_meta_24$Sample_Tx]  


#now make a function to plot these PCA plots in subsets
#use metadata not metadata_24 since it needs to be self-contained
make_pca_plots_24 <- function(subset_name, subset_drugs, hc_matrix, metadata, ind_num, drug_col) {
  # filter metadata
  keep_idx <- metadata$Drug %in% subset_drugs
  metadata_sub <- metadata[keep_idx, ]
  ind_sub <- ind_num[keep_idx]
  
  # subset expression matrix to same samples
  hc_matrix_sub <- hc_matrix[, keep_idx, drop = FALSE]
  
  drug_col_sub <- drug_col[names(drug_col) %in% unique(metadata_sub$Drug)]
  
  # run PCA on subset
  prcomp_sub <- prcomp(t(hc_matrix_sub), scale. = TRUE)
  
  ## PC1/PC2
  p1 <- autoplot(prcomp_sub, data = metadata_sub,
                 colour = "Drug", shape = "Species", size = 4,
                 x = 1, y = 2) +
    geom_text_repel(label = ind_sub,
                    vjust = -.5,
                    max.overlaps = 50,
                    segment.color = "grey",
                    segment.size = 0.1) +
    scale_color_manual(values = drug_col_sub) +
    ggtitle(bquote(.(subset_name) ~ "subset: log"[2]*"cpm PC1/PC2")) +
    theme_custom()
  
  ## PC2/PC3
  p2 <- autoplot(prcomp_sub, data = metadata_sub,
                 colour = "Drug", shape = "Species", size = 4,
                 x = 2, y = 3) +
    geom_text_repel(label = ind_sub,
                    vjust = -.5,
                    max.overlaps = 100,
                    segment.color = "grey",
                    segment.size = 0.1) +
    scale_color_manual(values = drug_col_sub) +
    ggtitle(bquote(.(subset_name) ~ "subset: log"[2]*"cpm PC2/PC3")) +
    theme_custom()
  
  list(p1 = p1, p2 = p2)
}

# ---- Run for each subset ----
upr_plots_24 <- make_pca_plots_24("UPR", c("TUN", "THA", "DMSO"), hc_cpm_mat_24, metadata_24, ind_num, drug_col)
ddr_plots_24 <- make_pca_plots_24("DDR", c("DOX", "NUTL", "DMSO"), hc_cpm_mat_24, metadata_24, ind_num, drug_col)
imr_plots_24 <- make_pca_plots_24("IMR", c("LPS", "TNFa", "H2O"), hc_cpm_mat_24, metadata_24, ind_num, drug_col)
mmr_plots_24 <- make_pca_plots_24("MMR", c("BPA", "PFOA", "EtOH"), hc_cpm_mat_24, metadata_24, ind_num, drug_col)

all_plots_subset_pca24 <- list(
  upr24_PC1_PC2 = upr_plots_24$p1,
  upr24_PC2_PC3 = upr_plots_24$p2,
  ddr24_PC1_PC2 = ddr_plots_24$p1,
  ddr24_PC2_PC3 = ddr_plots_24$p2,
  imr24_PC1_PC2 = imr_plots_24$p1,
  imr24_PC2_PC3 = imr_plots_24$p2,
  mmr24_PC1_PC2 = mmr_plots_24$p1,
  mmr24_PC2_PC3 = mmr_plots_24$p2
)

print(all_plots_subset_pca24)

# Loop through each plot and save
for (plot_name in names(all_plots_subset_pca24)) {
  save_plot(
    plot = all_plots_subset_pca24[[plot_name]],
    filename = paste0("Subset_PCA_24_", plot_name, "_EMP"),
    folder = output_folder
    )
}



```



```{r 2hr Subset PCA plots}
#now do the same thing you did above but filter out any 2hr samples

#make matrices into only 2hr samples
# hc_cpm_mat_2 <- hc_cpm_matrix[, metadata_2hr$Sample_Tx, drop = FALSE]

#UPR Subset
upr_tx <- c("TUN", "THA", "DMSO")
upr_meta_2 <- metadata_2hr %>% 
  dplyr::filter(Drug %in% upr_tx)
upr_cpm_2 <- hc_cpm_mat_2[, colnames(hc_cpm_mat_2) %in% upr_meta_2$Sample_Tx] 

#DDR Subset
ddr_tx <- c("DOX", "NUTL", "DMSO")
ddr_meta_2 <- metadata_2hr%>% 
  dplyr::filter(Drug %in% ddr_tx)
ddr_cpm_24 <- hc_cpm_mat_2[, colnames(hc_cpm_mat_2) %in% ddr_meta_2$Sample_Tx]  

#IMR Subset
imr_tx <- c("LPS", "TNFa", "H2O")
imr_meta_2 <- metadata_2hr %>% 
  dplyr::filter(Drug %in% imr_tx)
imr_cpm_2 <- hc_cpm_mat_2[, colnames(hc_cpm_mat_2) %in% imr_meta_2$Sample_Tx]  

#MMR Subset
mmr_tx <- c("BPA", "PFOA", "EtOH")
mmr_meta_2 <- metadata_2hr %>% 
  dplyr::filter(Drug %in% mmr_tx)
mmr_cpm_2 <- hc_cpm_mat_2[, colnames(hc_cpm_mat_2) %in% mmr_meta_2$Sample_Tx]  


#now make a function to plot these PCA plots in subsets
#use metadata not metadata_24 since it needs to be self-contained
make_pca_plots_2 <- function(subset_name, subset_drugs, hc_matrix, metadata, ind_num, drug_col) {
  # filter metadata
  keep_idx <- metadata$Drug %in% subset_drugs
  metadata_sub <- metadata[keep_idx, ]
  ind_sub <- ind_num[keep_idx]
  
  # subset expression matrix to same samples
  hc_matrix_sub <- hc_matrix[, keep_idx, drop = FALSE]
  
  drug_col_sub <- drug_col[names(drug_col) %in% unique(metadata_sub$Drug)]
  
  # run PCA on subset
  prcomp_sub <- prcomp(t(hc_matrix_sub), scale. = TRUE)
  
  ## PC1/PC2
  p1 <- autoplot(prcomp_sub, data = metadata_sub,
                 colour = "Drug", shape = "Species", size = 4,
                 x = 1, y = 2) +
    geom_text_repel(label = ind_sub,
                    vjust = -.5,
                    max.overlaps = 50,
                    segment.color = "grey",
                    segment.size = 0.1) +
    scale_color_manual(values = drug_col_sub) +
    ggtitle(bquote(.(subset_name) ~ "subset: log"[2]*"cpm PC1/PC2")) +
    theme_custom()
  
  ## PC2/PC3
  p2 <- autoplot(prcomp_sub, data = metadata_sub,
                 colour = "Drug", shape = "Species", size = 4,
                 x = 2, y = 3) +
    geom_text_repel(label = ind_sub,
                    vjust = -.5,
                    max.overlaps = 100,
                    segment.color = "grey",
                    segment.size = 0.1) +
    scale_color_manual(values = drug_col_sub) +
    ggtitle(bquote(.(subset_name) ~ "subset: log"[2]*"cpm PC2/PC3")) +
    theme_custom()
  
  list(p1 = p1, p2 = p2)
}

# ---- Run for each subset ----
upr_plots_2 <- make_pca_plots_2("UPR", c("TUN", "THA", "DMSO"), hc_cpm_mat_2, metadata_2hr, ind_num, drug_col)
ddr_plots_2 <- make_pca_plots_2("DDR", c("DOX", "NUTL", "DMSO"), hc_cpm_mat_2, metadata_2hr, ind_num, drug_col)
imr_plots_2 <- make_pca_plots_2("IMR", c("LPS", "TNFa", "H2O"), hc_cpm_mat_2, metadata_2hr, ind_num, drug_col)
mmr_plots_2 <- make_pca_plots_2("MMR", c("BPA", "PFOA", "EtOH"), hc_cpm_mat_2, metadata_2hr, ind_num, drug_col)

all_plots_subset_pca2 <- list(
  upr2_PC1_PC2 = upr_plots_2$p1,
  upr2_PC2_PC3 = upr_plots_2$p2,
  ddr2_PC1_PC2 = ddr_plots_2$p1,
  ddr2_PC2_PC3 = ddr_plots_2$p2,
  imr2_PC1_PC2 = imr_plots_2$p1,
  imr2_PC2_PC3 = imr_plots_2$p2,
  mmr2_PC1_PC2 = mmr_plots_2$p1,
  mmr2_PC2_PC3 = mmr_plots_2$p2
)

print(all_plots_subset_pca2)

# Loop through each plot and save
for (plot_name in names(all_plots_subset_pca2)) {
  save_plot(
    plot = all_plots_subset_pca2[[plot_name]],
    filename = paste0("Subset_PCA_2_", plot_name, "_EMP"),
    folder = output_folder
    )
}


```

#Correlation Heatmaps
```{r Spearman Heatmaps Correlation, fig.width=18, fig.height=14, warning=FALSE}
#first make correlation heatmaps of all samples
#using ComplexHeatmap

#First I want to alter the column names to be clearer
new_names <- metadata$Final_sample_name[match(colnames(x), metadata$Final_sample_name)]

colnames(hc_cpm_df) <- new_names

#prepare data
hc_matrix <- hc_cpm_df
colnames(hc_matrix) <- metadata$Sample_Tx  # Ensure column names match metadata

#compute Spearman correlation
cor_matrix_spearman <- cor(hc_matrix, method = "spearman", use = "everything")

#define a standard color scale where 0 = white
# col_fun <- colorRamp2(
#   breaks = c(-1,0,1),
#   colors = c("blue", "white", "red")
# )

#extract metadata for annotations
Individual <- as.character(metadata$Ind)
Species <- as.character(metadata$Species)
Time <- as.character(metadata$Time)
Stimulus <- as.character(metadata$Drug)

#define colors for my annotations
stim_col <- readRDS("data/theme/stimulus_color_palette_all.RDS")
ind_col <- readRDS("data/theme/individual_category_color_palette.RDS")
time_col <- readRDS("data/theme/time_category_color_palette.RDS")
spec_col <- readRDS("data/theme/species_category_color_palette.RDS")

#create my annotations
top_annotation <- HeatmapAnnotation(
  Individual = Individual, 
  Time = Time,
  Stimulus = Stimulus,
  Species = Species,
  col = list(
    Individual = ind_col,
    Time = time_col,
    Stimulus = stim_col,
    Species = spec_col
  )
)

# ---- Spearman heatmap for all samples ----
heatmap_spearman_all <- Heatmap(cor_matrix_spearman,
                                name = "Spearman",
                                top_annotation = top_annotation,
                                show_row_names = TRUE,
                                show_column_names = TRUE,
                                cluster_rows = TRUE,
                                cluster_columns = TRUE,
                                border = TRUE, 
                                show_row_dend = FALSE,
                                show_column_dend = FALSE,
                                use_raster = TRUE,
                                raster_quality = 2,
                                raster_device = "CairoPNG",
                                row_names_gp = gpar(fontsize = 8),
                                column_names_gp = gpar(fontsize = 8),
                                cell_fun = function(j, i, x, y, 
                                                    width, 
                                                    height, 
                                                    fill) {
          #draw a black border
          grid.rect(x = x, y = y, width = width, height = height,
                    gp = gpar(col = "black", lwd = 0.5, fill = fill))
        })

# draw(heatmap_spearman_all)

# ---- Define subsets ----
subsets <- list(
  UPR = c("TUN", "THA", "DMSO"),
  DDR = c("DOX", "NUTL", "DMSO"),
  IMR = c("LPS", "TNFa", "H2O"),
  MMR = c("BPA", "PFOA", "EtOH")
)

# ---- Loop through subsets ----
subset_heatmaps <- list()

for (subset_name in names(subsets)) {
  # Filter columns for this subset
  cols_subset <- metadata$Sample_Tx[metadata$Drug %in% subsets[[subset_name]]]
  mat_subset <- hc_matrix[, cols_subset, drop = FALSE]
  
  # Correlation
  cor_subset <- cor(mat_subset, method = "spearman", use = "everything")
  
  # Annotations for this subset
  top_ann_subset <- HeatmapAnnotation(
    Individual = metadata$Ind[metadata$Sample_Tx %in% cols_subset],
    Time = metadata$Time[metadata$Sample_Tx %in% cols_subset],
    Stimulus = metadata$Drug[metadata$Sample_Tx %in% cols_subset],
    Species = metadata$Species[metadata$Sample_Tx %in% cols_subset],
    col = list(
      Individual = ind_col,
      Time = time_col,
      Stimulus = stim_col,
      Species = spec_col
    )
  )
  
  # Heatmap
  heatmap_subset <- Heatmap(cor_subset,
                            name = paste0("Spearman_", subset_name),
                            top_annotation = top_ann_subset,
                            show_row_names = TRUE,
                            show_column_names = TRUE,
                            cluster_rows = TRUE,
                            cluster_columns = TRUE,
                            border = TRUE,
                            show_row_dend = FALSE,
                            show_column_dend = FALSE,
                            use_raster = TRUE,
                            raster_quality = 2,
                            raster_device = "CairoPNG",
                            row_names_gp = gpar(fontsize = 8),
                            column_names_gp = gpar(fontsize = 8), 
                            cell_fun = function(j, i, 
                                                x, y, 
                                                width, height, fill) {
          grid.rect(x = x, y = y, width = width, height = height,
                    gp = gpar(col = "black", lwd = 0.5, fill = fill))
        })
  
  
  # draw(heatmap_subset)
  subset_heatmaps[[subset_name]] <- heatmap_subset
}

#save my subset heatmaps
for (nm in names(subset_heatmaps)) {
  ht <- subset_heatmaps[[nm]]
  save_complex_heatmap(
    ht = ht,
    filename = paste0("CorHM_Spearman_", nm, "_EMP"),
    folder = output_folder,
    height = 18,
    width = 18
  )
  message("Saved subset heatmap: ", nm)
}

#save all samples heatmap
save_complex_heatmap(
  ht = heatmap_spearman_all,
  filename = "CorHM_Spearman_AllSamples_EMP",
  folder = output_folder,
  height = 40, width = 40)


```

##24hr Correlation Heatmaps
```{r Cor HMs Spearman 24hr Only}
#first make correlation heatmaps of all samples
#using ComplexHeatmap

hc_cpm_df_24 <- hc_cpm_df[, metadata_24$Final_sample_name, drop = FALSE]

#First I want to alter the column names so they're not inc time
clean_sample_names <- function(x) {
  #changing col names DOX_24_H_1 -> DOX_H1
  x <- gsub("_24_", "_", x)      
  x <- gsub("_([HC])_", "_\\1", x) 
  x <- gsub("_(\\d+)$", "\\1", x)
  return(x)
}

# Apply only to 24hr samples in metadata_24
meta_24 <- metadata_24 %>%
  mutate(Sample_Tx_clean = ifelse(
    grepl("_24_", Sample_Tx),
    clean_sample_names(Sample_Tx),
    Sample_Tx
  ))

colnames(hc_cpm_df_24) <- clean_sample_names(colnames(hc_cpm_df_24))

#prepare data
hc_matrix_24 <- hc_cpm_df_24
colnames(hc_matrix_24) <- meta_24$Sample_Tx_clean

#compute Spearman correlation
cor_matrix_spearman_24 <- cor(hc_matrix_24, method = "spearman", use = "everything")

#define a standard color scale where 0 = white
# col_fun <- colorRamp2(
#   breaks = c(-1,0,1),
#   colors = c("blue", "white", "red")
# )

#extract metadata for annotations
Individual <- as.character(meta_24$Ind)
Species <- as.character(meta_24$Species)
Stimulus <- as.character(meta_24$Drug)
Response <- as.character(meta_24$Response)


#define colors for my annotations
stim_col <- readRDS("data/theme/stimulus_color_palette_all.RDS")
ind_col <- readRDS("data/theme/individual_category_color_palette.RDS")
spec_col <- readRDS("data/theme/species_category_color_palette.RDS")
resp_col <- readRDS("data/theme/response_category_color_palette.RDS")

#create my annotations
top_annotation_24 <- HeatmapAnnotation(
  Individual = Individual, 
  Stimulus = Stimulus,
  Species = Species,
  Response = Response,
  col = list(
    Individual = ind_col,
    Stimulus = stim_col,
    Species = spec_col,
    Response = resp_col
  )
)

#spearman heatmap for all samples
heatmap_spearman_24 <- Heatmap(cor_matrix_spearman_24,
                                name = "Spearman",
                                top_annotation = top_annotation_24,
                                show_row_names = TRUE,
                                show_column_names = TRUE,
                                cluster_rows = TRUE,
                                cluster_columns = TRUE,
                                border = TRUE, 
                                show_row_dend = FALSE,
                                show_column_dend = FALSE,
                                use_raster = TRUE,
                                raster_quality = 2,
                                raster_device = "CairoPNG",
                                row_names_gp = gpar(fontsize = 8),
                                column_names_gp = gpar(fontsize = 8),
                                layer_fun = function(j, i, x, y, 
                                                    width, 
                                                    height, 
                                                    fill) {
          #draw a black border
          grid.rect(x = x, y = y, width = width, height = height,
                    gp = gpar(col = "black", lwd = 0.5, fill = fill))
        })

# draw(heatmap_spearman_24)

# ---- Define subsets ----
subsets <- list(
  UPR = c("TUN", "THA", "DMSO"),
  DDR = c("DOX", "NUTL", "DMSO"),
  IMR = c("LPS", "TNFa", "H2O"),
  MMR = c("BPA", "PFOA", "EtOH")
)

# ---- Loop through subsets ----
subset_heatmaps_24 <- list()

for (subset_name in names(subsets)) {
  # Filter columns for this subset
  cols_subset_24 <- meta_24$Sample_Tx_clean[meta_24$Drug %in% subsets[[subset_name]]]
  mat_subset <- hc_matrix_24[, cols_subset_24, drop = FALSE]
  
  # Correlation
  cor_subset_24 <- cor(mat_subset, method = "spearman", use = "everything")
  
  # Annotations for this subset
  top_ann_subset_24 <- HeatmapAnnotation(
    Individual = meta_24$Ind[meta_24$Sample_Tx_clean %in% cols_subset_24],
    Stimulus = meta_24$Drug[meta_24$Sample_Tx_clean %in% cols_subset_24],
    Species = meta_24$Species[meta_24$Sample_Tx_clean %in% cols_subset_24],
    col = list(
      Individual = ind_col,
      Stimulus = stim_col,
      Species = spec_col
    )
  )
  
  # Heatmap
  heatmap_subset_24 <- Heatmap(cor_subset_24,
                            name = paste0("Spearman_24_", subset_name),
                            top_annotation = top_ann_subset_24,
                            show_row_names = TRUE,
                            show_column_names = TRUE,
                            cluster_rows = TRUE,
                            cluster_columns = TRUE,
                            border = TRUE,
                            show_row_dend = FALSE,
                            show_column_dend = FALSE,
                            use_raster = TRUE,
                            raster_quality = 2,
                            raster_device = "CairoPNG",
                            row_names_gp = gpar(fontsize = 8),
                            column_names_gp = gpar(fontsize = 8), 
                            layer_fun = function(j, i, 
                                                x, y, 
                                                width, height, fill) {
          grid.rect(x = x, y = y, width = width, height = height,
                    gp = gpar(col = "black", lwd = 0.5, fill = fill))
        })
  
  
  # draw(heatmap_subset_24)
  subset_heatmaps_24[[subset_name]] <- heatmap_subset_24
}

#save my subset heatmaps
for (nm in names(subset_heatmaps_24)) {
  ht <- subset_heatmaps_24[[nm]]
  save_complex_heatmap(
    ht = ht,
    filename = paste0("CorHM_Spearman_24_", nm, "_EMP_251002"),
    folder = output_folder,
    height = 12,
    width = 12
  )
  message("Saved subset heatmap: ", nm)
}

#save all samples heatmap
save_complex_heatmap(
  ht = heatmap_spearman_24,
  filename = "CorHM_Spearman_24hr_EMP_251002",
  folder = output_folder,
  height = 18,
  width = 18
)

```


```{r 2hr Spearman Correlation HM}
hc_cpm_df_2 <- hc_cpm_df[, metadata_2hr$Final_sample_name, drop = FALSE]

#First I want to alter the column names so they're not inc time
clean_sample_names <- function(x) {
  #changing col names DOX_24_H_1 -> DOX_H1
  x <- gsub("_2_", "_", x)      
  x <- gsub("_([HC])_", "_\\1", x) 
  x <- gsub("_(\\d+)$", "\\1", x)
  return(x)
}

# Apply only to 24hr samples in metadata_24
meta_2 <- metadata_2hr %>%
  mutate(Sample_Tx_clean = ifelse(
    grepl("_2_", Sample_Tx),
    clean_sample_names(Sample_Tx),
    Sample_Tx
  ))

colnames(hc_cpm_df_2) <- clean_sample_names(colnames(hc_cpm_df_2))

#prepare data
hc_matrix_2 <- hc_cpm_df_2
colnames(hc_matrix_2) <- meta_2$Sample_Tx_clean

#compute Spearman correlation
cor_matrix_spearman_2 <- cor(hc_matrix_2, method = "spearman", use = "everything")

#define a standard color scale where 0 = white
col_fun <- colorRamp2(
  breaks = c(-1,0,1),
  colors = c("blue", "white", "red")
)

#extract metadata for annotations
Individual <- as.character(meta_2$Ind)
Species <- as.character(meta_2$Species)
Stimulus <- as.character(meta_2$Drug)
Response <- as.character(meta_2$Response)


#define colors for my annotations
stim_col <- readRDS("data/theme/stimulus_color_palette_all.RDS")
ind_col <- readRDS("data/theme/individual_category_color_palette.RDS")
spec_col <- readRDS("data/theme/species_category_color_palette.RDS")
resp_col <- readRDS("data/theme/response_category_color_palette.RDS")

#create my annotations
top_annotation_2 <- HeatmapAnnotation(
  Individual = Individual, 
  Stimulus = Stimulus,
  Species = Species,
  Response = Response,
  col = list(
    Individual = ind_col,
    Stimulus = stim_col,
    Species = spec_col,
    Response = resp_col
  )
)

#spearman heatmap for all samples
heatmap_spearman_2 <- Heatmap(cor_matrix_spearman_2,
                                name = "Spearman",
                                col = col_fun,
                                top_annotation = top_annotation_2,
                                show_row_names = TRUE,
                                show_column_names = TRUE,
                                cluster_rows = TRUE,
                                cluster_columns = TRUE,
                                border = TRUE, 
                                show_row_dend = FALSE,
                                show_column_dend = FALSE,
                                use_raster = TRUE,
                                raster_quality = 2,
                                raster_device = "CairoPNG",
                                row_names_gp = gpar(fontsize = 8),
                                column_names_gp = gpar(fontsize = 8),
                                layer_fun = function(j, i, x, y, 
                                                    width, 
                                                    height, 
                                                    fill) {
          #draw a black border
          grid.rect(x = x, y = y, width = width, height = height,
                    gp = gpar(col = "black", lwd = 0.5, fill = fill))
        })

# draw(heatmap_spearman_2)

# ---- Define subsets ----
subsets <- list(
  UPR = c("TUN", "THA", "DMSO"),
  DDR = c("DOX", "NUTL", "DMSO"),
  IMR = c("LPS", "TNFa", "H2O"),
  MMR = c("BPA", "PFOA", "EtOH")
)

# ---- Loop through subsets ----
subset_heatmaps_2 <- list()

for (subset_name in names(subsets)) {
  # Filter columns for this subset
  cols_subset_2 <- meta_2$Sample_Tx_clean[meta_2$Drug %in% subsets[[subset_name]]]
  mat_subset <- hc_matrix_2[, cols_subset_2, drop = FALSE]
  
  # Correlation
  cor_subset_2 <- cor(mat_subset, method = "spearman", use = "everything")
  
  # Annotations for this subset
  top_ann_subset_2 <- HeatmapAnnotation(
    Individual = meta_2$Ind[meta_2$Sample_Tx_clean %in% cols_subset_2],
    Stimulus = meta_2$Drug[meta_2$Sample_Tx_clean %in% cols_subset_2],
    Species = meta_2$Species[meta_2$Sample_Tx_clean %in% cols_subset_2],
    col = list(
      Individual = ind_col,
      Stimulus = stim_col,
      Species = spec_col
    )
  )
  
  # Heatmap
  heatmap_subset_2 <- Heatmap(cor_subset_2,
                            name = paste0("Spearman_2_", subset_name),
                            top_annotation = top_ann_subset_2,
                            col = col_fun,
                            show_row_names = TRUE,
                            show_column_names = TRUE,
                            cluster_rows = TRUE,
                            cluster_columns = TRUE,
                            border = TRUE,
                            show_row_dend = FALSE,
                            show_column_dend = FALSE,
                            use_raster = TRUE,
                            raster_quality = 2,
                            raster_device = "CairoPNG",
                            row_names_gp = gpar(fontsize = 8),
                            column_names_gp = gpar(fontsize = 8), 
                            layer_fun = function(j, i, 
                                                x, y, 
                                                width, height, fill) {
          grid.rect(x = x, y = y, width = width, height = height,
                    gp = gpar(col = "black", lwd = 0.5, fill = fill))
        })
  
  
  # draw(heatmap_subset_2)
  subset_heatmaps_2[[subset_name]] <- heatmap_subset_2
}

#save my subset heatmaps
for (nm in names(subset_heatmaps_2)) {
  ht <- subset_heatmaps_2[[nm]]
  save_complex_heatmap(
    ht = ht,
    filename = paste0("CorHM_Spearman_2_", nm, "_EMP"),
    folder = output_folder,
    height = 12,
    width = 12
  )
  message("Saved subset heatmap: ", nm)
}

#save all samples heatmap
save_complex_heatmap(
  ht = heatmap_spearman_2,
  filename = "CorHM_Spearman_24hr_EMP",
  folder = output_folder,
  height = 18,
  width = 18
)

```



#Perform Differential Expression Analysis
```{r DE Analysis}
#filter my counts for DE
#make sure that hc_counts with my raw counts information has the right column names
# identical(colnames(hc_counts_df), colnames(hc_cpm_df))
#TRUE

# x = hc_counts_df[row.names(hc_cpm_df), ] %>%
#   as.matrix()
#now i've filtered my raw counts for DE by the number of genes that I got after rowMeans filtering

#modify my metadata to match with the rownames being my sample names in columns here
# metadata_2 <- metadata %>%
#   as.data.frame()

colnames(x) <- metadata_2$Final_sample_name
rownames(metadata_2) <- metadata_2$Final_sample_name

metadata_2$Cond <- make.names(metadata_2$Cond)
metadata_2$Ind <- as.character(metadata_2$Ind)

# saveRDS(metadata_2, "data/de/metadata_2_de.RDS")
# saveRDS(x, "data/de/x_counts_de.RDS")

#read in your saved metadata_2 and x so it doesn't get altered
metadata_2 <- readRDS("data/de/metadata_2_de.RDS")
x <- readRDS("data/de/x_counts_de.RDS")

#now that I've formatted my dataframes, I'm going to go ahead and start the process of DE

#create DGEList object
dge <- DGEList(counts = x)
#make sure that the groups are based on my column names
dge$samples$group <- factor(metadata_2$Cond)
#now perform TMM normalization for library size
dge <- calcNormFactors(dge, method = "TMM")

#before making my design matrix, factor
metadata_2$Ind_Num <- factor(metadata_2$Ind_Num, levels = unique(metadata_2$Ind_Num))
metadata_2$Drug <- factor(metadata_2$Drug, levels = c("TUN", "THA", "DOX", "NUTL", "DMSO", "LPS", "TNFa", "H2O", "BPA", "PFOA", "EtOH"))
metadata_2$Time <- factor(metadata_2$Time, levels = c("2", "24"))
metadata_2$Species <- factor(metadata_2$Species, levels = c("C", "H"))
metadata_2$Cond <- factor(metadata_2$Cond, levels = unique(metadata_2$Cond))

#create my design matrix
design <- model.matrix(~ 0 + metadata_2$Cond)
colnames(design) <- gsub("metadata_2\\$Cond", "", colnames(design))

# saveRDS(design, "data/de/design_matrix.RDS")

#since I factored condition above, they stayed in the right order but keep an eye on them

#run duplicate correlation for individual effect
corfit <- duplicateCorrelation(object = dge$counts,
                               design = design,
                               block = metadata_2$Ind_Num)

#run voom transformation and plot it
v <- voom(dge, design, 
          block = metadata_2$Ind_Num, 
          correlation = corfit$consensus.correlation)

#fit my linear model
fit <- lmFit(v, design,
             block = metadata_2$Ind_Num,
             correlation = corfit$consensus.correlation)

#put together my contrast matrix
contrast_matrix <- makeContrasts(
  V.TUN2_C = TUN_2_C - DMSO_2_C,
  V.THA2_C = THA_2_C - DMSO_2_C,
  V.DOX2_C = DOX_2_C - DMSO_2_C,
  V.NUTL2_C = NUTL_2_C - DMSO_2_C,
  V.LPS2_C = LPS_2_C - H2O_2_C,
  V.TNFa2_C = TNFa_2_C - H2O_2_C,
  V.BPA2_C = BPA_2_C - EtOH_2_C,
  V.PFOA2_C = PFOA_2_C - EtOH_2_C,
  V.TUN24_C = TUN_24_C - DMSO_24_C,
  V.THA24_C = THA_24_C - DMSO_24_C,
  V.DOX24_C = DOX_24_C - DMSO_24_C,
  V.NUTL24_C = NUTL_24_C - DMSO_24_C,
  V.LPS24_C = LPS_24_C - H2O_24_C,
  V.TNFa24_C = TNFa_24_C - H2O_24_C,
  V.BPA24_C = BPA_24_C - EtOH_24_C,
  V.PFOA24_C = PFOA_24_C - EtOH_24_C,
  V.TUN2_H = TUN_2_H - DMSO_2_H,
  V.THA2_H = THA_2_H - DMSO_2_H,
  V.DOX2_H = DOX_2_H - DMSO_2_H,
  V.NUTL2_H = NUTL_2_H - DMSO_2_H,
  V.LPS2_H = LPS_2_H - H2O_2_H,
  V.TNFa2_H = TNFa_2_H - H2O_2_H,
  V.BPA2_H = BPA_2_H - EtOH_2_H,
  V.PFOA2_H = PFOA_2_H - EtOH_2_H,
  V.TUN24_H = TUN_24_H - DMSO_24_H,
  V.THA24_H = THA_24_H - DMSO_24_H,
  V.DOX24_H = DOX_24_H - DMSO_24_H,
  V.NUTL24_H = NUTL_24_H - DMSO_24_H,
  V.LPS24_H = LPS_24_H - H2O_24_H,
  V.TNFa24_H = TNFa_24_H - H2O_24_H,
  V.BPA24_H = BPA_24_H - EtOH_24_H,
  V.PFOA24_H = PFOA_24_H - EtOH_24_H,
  levels = design
)

#apply these contrasts to compare drug to matched vehicles
fit2 <- contrasts.fit(fit, contrast_matrix)
fit2 <- eBayes(fit2)

#plot the mean-variance trend
plotSA(fit2, main = "Dissertation Model: MV Trend")

#pull my results summary for DEGs
results_summary <- decideTests(fit2, 
                               adjust.method = "BH",
                               p.value = 0.05)

summary(results_summary)

```

#Create Toptables
```{r DE Toptables Chimp}
#make toptables of DEGs - start with Chimp


Toptable_V.DOX2_C <- topTable(fit = fit2, 
                            coef = "V.DOX2_C",
                            number = nrow(x), 
                            adjust.method = "BH", 
                            p.value = 1, 
                            sort.by = "none")

Toptable_V.NUTL2_C <- topTable(fit = fit2, 
                            coef = "V.NUTL2_C",
                            number = nrow(x), 
                            adjust.method = "BH", 
                            p.value = 1, 
                            sort.by = "none")

Toptable_V.LPS2_C <- topTable(fit = fit2, 
                            coef = "V.LPS2_C",
                            number = nrow(x), 
                            adjust.method = "BH", 
                            p.value = 1, 
                            sort.by = "none")

Toptable_V.TNFa2_C <- topTable(fit = fit2, 
                            coef = "V.TNFa2_C",
                            number = nrow(x), 
                            adjust.method = "BH", 
                            p.value = 1, 
                            sort.by = "none")

Toptable_V.BPA2_C <- topTable(fit = fit2, 
                            coef = "V.BPA2_C",
                            number = nrow(x), 
                            adjust.method = "BH", 
                            p.value = 1, 
                            sort.by = "none")

Toptable_V.PFOA2_C <- topTable(fit = fit2, 
                            coef = "V.PFOA2_C",
                            number = nrow(x), 
                            adjust.method = "BH", 
                            p.value = 1, 
                            sort.by = "none")

#24hr toptables
Toptable_V.TUN24_C <- topTable(fit = fit2, 
                            coef = "V.TUN24_C",
                            number = nrow(x), 
                            adjust.method = "BH", 
                            p.value = 1, 
                            sort.by = "none")

Toptable_V.THA24_C <- topTable(fit = fit2, 
                            coef = "V.THA24_C",
                            number = nrow(x), 
                            adjust.method = "BH", 
                            p.value = 1, 
                            sort.by = "none")

Toptable_V.DOX24_C <- topTable(fit = fit2, 
                            coef = "V.DOX24_C",
                            number = nrow(x), 
                            adjust.method = "BH", 
                            p.value = 1, 
                            sort.by = "none")

Toptable_V.NUTL24_C <- topTable(fit = fit2, 
                            coef = "V.NUTL24_C",
                            number = nrow(x), 
                            adjust.method = "BH", 
                            p.value = 1, 
                            sort.by = "none")

Toptable_V.LPS24_C <- topTable(fit = fit2, 
                            coef = "V.LPS24_C",
                            number = nrow(x), 
                            adjust.method = "BH", 
                            p.value = 1, 
                            sort.by = "none")

Toptable_V.TNFa24_C <- topTable(fit = fit2, 
                            coef = "V.TNFa24_C",
                            number = nrow(x), 
                            adjust.method = "BH", 
                            p.value = 1, 
                            sort.by = "none")

Toptable_V.BPA24_C <- topTable(fit = fit2, 
                            coef = "V.BPA24_C",
                            number = nrow(x), 
                            adjust.method = "BH", 
                            p.value = 1, 
                            sort.by = "none")

Toptable_V.PFOA24_C <- topTable(fit = fit2, 
                            coef = "V.PFOA24_C",
                            number = nrow(x), 
                            adjust.method = "BH", 
                            p.value = 1, 
                            sort.by = "none")

```

```{r DE Toptables Human}
#2hr Human
Toptable_V.TUN2_H <- topTable(fit = fit2, 
                            coef = "V.TUN2_H",
                            number = nrow(x), 
                            adjust.method = "BH", 
                            p.value = 1, 
                            sort.by = "none")

Toptable_V.THA2_H <- topTable(fit = fit2, 
                            coef = "V.THA2_H",
                            number = nrow(x), 
                            adjust.method = "BH", 
                            p.value = 1, 
                            sort.by = "none")

Toptable_V.DOX2_H <- topTable(fit = fit2, 
                            coef = "V.DOX2_H",
                            number = nrow(x), 
                            adjust.method = "BH", 
                            p.value = 1, 
                            sort.by = "none")

Toptable_V.NUTL2_H <- topTable(fit = fit2, 
                            coef = "V.NUTL2_H",
                            number = nrow(x), 
                            adjust.method = "BH", 
                            p.value = 1, 
                            sort.by = "none")

Toptable_V.LPS2_H <- topTable(fit = fit2, 
                            coef = "V.LPS2_H",
                            number = nrow(x), 
                            adjust.method = "BH", 
                            p.value = 1, 
                            sort.by = "none")

Toptable_V.TNFa2_H <- topTable(fit = fit2, 
                            coef = "V.TNFa2_H",
                            number = nrow(x), 
                            adjust.method = "BH", 
                            p.value = 1, 
                            sort.by = "none")

Toptable_V.BPA2_H <- topTable(fit = fit2, 
                            coef = "V.BPA2_H",
                            number = nrow(x), 
                            adjust.method = "BH", 
                            p.value = 1, 
                            sort.by = "none")

Toptable_V.PFOA2_H <- topTable(fit = fit2, 
                            coef = "V.PFOA2_H",
                            number = nrow(x), 
                            adjust.method = "BH", 
                            p.value = 1, 
                            sort.by = "none")

#24hr toptables
Toptable_V.TUN24_H <- topTable(fit = fit2, 
                            coef = "V.TUN24_H",
                            number = nrow(x), 
                            adjust.method = "BH", 
                            p.value = 1, 
                            sort.by = "none")

Toptable_V.THA24_H <- topTable(fit = fit2, 
                            coef = "V.THA24_H",
                            number = nrow(x), 
                            adjust.method = "BH", 
                            p.value = 1, 
                            sort.by = "none")

Toptable_V.DOX24_H <- topTable(fit = fit2, 
                            coef = "V.DOX24_H",
                            number = nrow(x), 
                            adjust.method = "BH", 
                            p.value = 1, 
                            sort.by = "none")

Toptable_V.NUTL24_H <- topTable(fit = fit2, 
                            coef = "V.NUTL24_H",
                            number = nrow(x), 
                            adjust.method = "BH", 
                            p.value = 1, 
                            sort.by = "none")

Toptable_V.LPS24_H <- topTable(fit = fit2, 
                            coef = "V.LPS24_H",
                            number = nrow(x), 
                            adjust.method = "BH", 
                            p.value = 1, 
                            sort.by = "none")

Toptable_V.TNFa24_H <- topTable(fit = fit2, 
                            coef = "V.TNFa24_H",
                            number = nrow(x), 
                            adjust.method = "BH", 
                            p.value = 1, 
                            sort.by = "none")

Toptable_V.BPA24_H <- topTable(fit = fit2, 
                            coef = "V.BPA24_H",
                            number = nrow(x), 
                            adjust.method = "BH", 
                            p.value = 1, 
                            sort.by = "none")

Toptable_V.PFOA24_H <- topTable(fit = fit2, 
                            coef = "V.PFOA24_H",
                            number = nrow(x), 
                            adjust.method = "BH", 
                            p.value = 1, 
                            sort.by = "none")

```

#Combine Toptables List
```{r Combined Toptables}

c_toptables_2 <- list(
  "V.TUN2_C" = Toptable_V.TUN2_C, 
  "V.THA2_C" = Toptable_V.THA2_C, 
  "V.DOX2_C" = Toptable_V.DOX2_C,
  "V.NUTL2_C" = Toptable_V.NUTL2_C, 
  "V.LPS2_C" = Toptable_V.LPS2_C, 
  "V.TNFa2_C" = Toptable_V.TNFa2_C,
  "V.BPA2_C" = Toptable_V.BPA2_C,
  "V.PFOA2_C" = Toptable_V.PFOA2_C
)

h_toptables_2 <- list(
  "V.TUN2_H" = Toptable_V.TUN2_H, 
  "V.THA2_H" = Toptable_V.THA2_H, 
  "V.DOX2_H" = Toptable_V.DOX2_H,
  "V.NUTL2_H" = Toptable_V.NUTL2_H, 
  "V.LPS2_H" = Toptable_V.LPS2_H, 
  "V.TNFa2_H" = Toptable_V.TNFa2_H,
  "V.BPA2_H" = Toptable_V.BPA2_H,
  "V.PFOA2_H" = Toptable_V.PFOA2_H
)

c_toptables_24 <- list(
  "V.TUN24_C" = Toptable_V.TUN24_C,
  "V.THA24_C" = Toptable_V.THA24_C,
  "V.DOX24_C" = Toptable_V.DOX24_C,
  "V.NUTL24_C" = Toptable_V.NUTL24_C,
  "V.LPS24_C" = Toptable_V.LPS24_C,
  "V.TNFa24_C" = Toptable_V.TNFa24_C,
  "V.BPA24_C" = Toptable_V.BPA24_C,
  "V.PFOA24_C" = Toptable_V.PFOA24_C
)

h_toptables_24 <- list(
  "V.TUN24_H" = Toptable_V.TUN24_H,
  "V.THA24_H" = Toptable_V.THA24_H,
  "V.DOX24_H" = Toptable_V.DOX24_H,
  "V.NUTL24_H" = Toptable_V.NUTL24_H,
  "V.LPS24_H" = Toptable_V.LPS24_H,
  "V.TNFa24_H" = Toptable_V.TNFa24_H,
  "V.BPA24_H" = Toptable_V.BPA24_H,
  "V.PFOA24_H" = Toptable_V.PFOA24_H
)

c_toptables_all <- list(
  "V.TUN2_C" = Toptable_V.TUN2_C, 
  "V.THA2_C" = Toptable_V.THA2_C, 
  "V.DOX2_C" = Toptable_V.DOX2_C,
  "V.NUTL2_C" = Toptable_V.NUTL2_C, 
  "V.LPS2_C" = Toptable_V.LPS2_C, 
  "V.TNFa2_C" = Toptable_V.TNFa2_C,
  "V.BPA2_C" = Toptable_V.BPA2_C,
  "V.PFOA2_C" = Toptable_V.PFOA2_C,
  "V.TUN24_C" = Toptable_V.TUN24_C,
  "V.THA24_C" = Toptable_V.THA24_C,
  "V.DOX24_C" = Toptable_V.DOX24_C,
  "V.NUTL24_C" = Toptable_V.NUTL24_C,
  "V.LPS24_C" = Toptable_V.LPS24_C,
  "V.TNFa24_C" = Toptable_V.TNFa24_C,
  "V.BPA24_C" = Toptable_V.BPA24_C,
  "V.PFOA24_C" = Toptable_V.PFOA24_C
)

h_toptables_all <- list(
  "V.TUN2_H" = Toptable_V.TUN2_H, 
  "V.THA2_H" = Toptable_V.THA2_H, 
  "V.DOX2_H" = Toptable_V.DOX2_H,
  "V.NUTL2_H" = Toptable_V.NUTL2_H, 
  "V.LPS2_H" = Toptable_V.LPS2_H, 
  "V.TNFa2_H" = Toptable_V.TNFa2_H,
  "V.BPA2_H" = Toptable_V.BPA2_H,
  "V.PFOA2_H" = Toptable_V.PFOA2_H,
  "V.TUN24_H" = Toptable_V.TUN24_H,
  "V.THA24_H" = Toptable_V.THA24_H,
  "V.DOX24_H" = Toptable_V.DOX24_H,
  "V.NUTL24_H" = Toptable_V.NUTL24_H,
  "V.LPS24_H" = Toptable_V.LPS24_H,
  "V.TNFa24_H" = Toptable_V.TNFa24_H,
  "V.BPA24_H" = Toptable_V.BPA24_H,
  "V.PFOA24_H" = Toptable_V.PFOA24_H
)

hc_toptables <- list(
  "V.TUN2_H" = Toptable_V.TUN2_H,
  "V.THA2_H" = Toptable_V.THA2_H,
  "V.DOX2_H" = Toptable_V.DOX2_H,
  "V.NUTL2_H" = Toptable_V.NUTL2_H,
  "V.LPS2_H" = Toptable_V.LPS2_H,
  "V.TNFa2_H" = Toptable_V.TNFa2_H,
  "V.BPA2_H" = Toptable_V.BPA2_H,
  "V.PFOA2_H" = Toptable_V.PFOA2_H,
  "V.TUN24_H" = Toptable_V.TUN24_H,
  "V.THA24_H" = Toptable_V.THA24_H,
  "V.DOX24_H" = Toptable_V.DOX24_H,
  "V.NUTL24_H" = Toptable_V.NUTL24_H,
  "V.LPS24_H" = Toptable_V.LPS24_H,
  "V.TNFa24_H" = Toptable_V.TNFa24_H,
  "V.BPA24_H" = Toptable_V.BPA24_H,
  "V.PFOA24_H" = Toptable_V.PFOA24_H,
  "V.TUN2_C" = Toptable_V.TUN2_C,
  "V.THA2_C" = Toptable_V.THA2_C,
  "V.DOX2_C" = Toptable_V.DOX2_C,
  "V.NUTL2_C" = Toptable_V.NUTL2_C,
  "V.LPS2_C" = Toptable_V.LPS2_C,
  "V.TNFa2_C" = Toptable_V.TNFa2_C,
  "V.BPA2_C" = Toptable_V.BPA2_C,
  "V.PFOA2_C" = Toptable_V.PFOA2_C,
  "V.TUN24_C" = Toptable_V.TUN24_C,
  "V.THA24_C" = Toptable_V.THA24_C,
  "V.DOX24_C" = Toptable_V.DOX24_C,
  "V.NUTL24_C" = Toptable_V.NUTL24_C,
  "V.LPS24_C" = Toptable_V.LPS24_C,
  "V.TNFa24_C" = Toptable_V.TNFa24_C,
  "V.BPA24_C" = Toptable_V.BPA24_C,
  "V.PFOA24_C" = Toptable_V.PFOA24_C
)


#save each of these toptables in a list so I can access them later for analysis 
# saveRDS(list(
#   "V.TUN2_H" = Toptable_V.TUN2_H,
#   "V.THA2_H" = Toptable_V.THA2_H,
#   "V.DOX2_H" = Toptable_V.DOX2_H,
#   "V.NUTL2_H" = Toptable_V.NUTL2_H,
#   "V.LPS2_H" = Toptable_V.LPS2_H,
#   "V.TNFa2_H" = Toptable_V.TNFa2_H,
#   "V.BPA2_H" = Toptable_V.BPA2_H,
#   "V.PFOA2_H" = Toptable_V.PFOA2_H,
#   "V.TUN24_H" = Toptable_V.TUN24_H,
#   "V.THA24_H" = Toptable_V.THA24_H,
#   "V.DOX24_H" = Toptable_V.DOX24_H,
#   "V.NUTL24_H" = Toptable_V.NUTL24_H,
#   "V.LPS24_H" = Toptable_V.LPS24_H,
#   "V.TNFa24_H" = Toptable_V.TNFa24_H,
#   "V.BPA24_H" = Toptable_V.BPA24_H,
#   "V.PFOA24_H" = Toptable_V.PFOA24_H,
#   "V.TUN2_C" = Toptable_V.TUN2_C,
#   "V.THA2_C" = Toptable_V.THA2_C,
#   "V.DOX2_C" = Toptable_V.DOX2_C,
#   "V.NUTL2_C" = Toptable_V.NUTL2_C,
#   "V.LPS2_C" = Toptable_V.LPS2_C,
#   "V.TNFa2_C" = Toptable_V.TNFa2_C,
#   "V.BPA2_C" = Toptable_V.BPA2_C,
#   "V.PFOA2_C" = Toptable_V.PFOA2_C,
#   "V.TUN24_C" = Toptable_V.TUN24_C,
#   "V.THA24_C" = Toptable_V.THA24_C,
#   "V.DOX24_C" = Toptable_V.DOX24_C,
#   "V.NUTL24_C" = Toptable_V.NUTL24_C,
#   "V.LPS24_C" = Toptable_V.LPS24_C,
#   "V.TNFa24_C" = Toptable_V.TNFa24_C,
#   "V.BPA24_C" = Toptable_V.BPA24_C,
#   "V.PFOA24_C" = Toptable_V.PFOA24_C
# ), file = "data/de/Toptable_list.RDS")


#save each of these toptables for each comparison
#convert rownames to Entrez_ID for every topTable
# toptable_list_entrez <- lapply(toptable_list, function(df) {
#   df$Entrez_ID <- rownames(df)
#   df <- df[, c("Entrez_ID", setdiff(colnames(df), "Entrez_ID"))]  # Entrez_ID first
#   return(df)
# })
# 
# #save csv 
# for (nm in names(toptable_list_entrez)) {
#   write.csv(
#     toptable_list_entrez[[nm]],
#     file = file.path("data/de", paste0("Toptable_", nm, ".csv")),
#     row.names = FALSE
#   )
# }

#save as an RDS as well
# saveRDS(toptable_list_entrez, file = "data/de/Toptable_list.RDS")

#now go ahead and filter for adj. p value < 0.05 to make a list of all significant DEGs in these lists per comparison
# toptable_sig_list <- list()

# #make a function to loop through toptables
# for (nm in names(toptable_list)) {
#   df <- toptable_list[[nm]]
#   
#   #find the adj. p value to filter by
#   if ("adj.P.Val" %in% colnames(df)) {
#     df_sig <- df[df$adj.P.Val < 0.05, ]
#   } else {
#     warning(paste("No adj. p-value column in", nm))
#     next
#   }
#   
#   #skip tables with 0 significant DEGs
#   if (nrow(df_sig) == 0) {
#     message(paste("Skipping", nm, "- no significant DEGs"))
#     next
#   }
#   
#   #add filtered table to list
#   toptable_sig_list[[nm]] <- df_sig
# }

#save filtered significant list as an RDS
# saveRDS(toptable_sig_list, file = "data/de/Toptable_sig_list.RDS")

#read in my toptable list for downstream analysis
toptable_list <- readRDS("data/de/Toptable_list.RDS")
toptable_sig_list <- readRDS("data/de/Toptable_sig_list.RDS")

```

```{r Joined Toptable 24hr}
#I want to make a toptable that has all of the data for both species all combined and not just a list

#define the treatments to pull and species
# tx_24 <- c("TUN24", "THA24", "DOX24", "NUTL24", "LPS24", "TNFa24", "BPA24", "PFOA24")

# spec <- c("H", "C")

#make a function to merge each of these toptables into one
# tables_to_merge <- c()
# for (trt in tx_24) {
#   for (sp in spec) {
#     key <- paste0("V.", trt, "_", sp)
#     if (key %in% names(toptable_list_entrez)) {
#       tables_to_merge[[key]] <- toptable_list_entrez[[key]]
#     }
#   }
# }
# combined_24hr <- tables_to_merge[[1]]
# 
# #add suffix to all other tables before merging to keep track of treatment/species
# for (i in 2:length(tables_to_merge)) {
#   df <- tables_to_merge[[i]]
#   
#   #rename columns to include treatment/species
#   df <- df %>%
#     rename_with(~ paste0(names(tables_to_merge)[i], "_", .), -Entrez_ID)
#   
#   #full join by Entrez_ID
#   combined_24hr <- full_join(combined_24hr, df, by = "Entrez_ID")
# }

# saveRDS(combined_24hr, "data/de/Combined_24hr_Toptable_EMP_251001.RDS")

combined_24hr <- readRDS("data/de/Combined_24hr_Toptable_EMP_251001.RDS")

```

```{r Volcano Plots DEGs All Timepoints}
#now I want to create a function to plot volcano plots for all comparisons

generate_volcano_plot <- function(toptable, title) {
  
  #check for entrezid 
  if(!"Entrez_ID" %in% colnames(toptable)) stop("Entrez_ID col not present")
  
  #make significance labels
  toptable <- toptable %>% 
    mutate(Significance = case_when(
      logFC > 0 & adj.P.Val < 0.05 ~ "Upregulated",
      logFC < 0 & adj.P.Val < 0.05 ~ "Downregulated",
      TRUE  ~ "Not Significant"
    ))
  
  #factor significance
  toptable$Significance <- factor(
    toptable$Significance, 
    levels = c("Upregulated", 
               "Not Significant", 
               "Downregulated")
  )
  
  #count genes in each category
  upgenes <- sum(toptable$Significance == "Upregulated")
  nsgenes <- sum(toptable$Significance == "Not Significant")
  downgenes <- sum(toptable$Significance == "Downregulated")
  
  
  #labels for legend
  legend_lab <- c(
    paste0("Upregulated: ", upgenes),
    paste0("Not Significant: ", nsgenes),
    paste0("Downregulated: ", downgenes)
  )
  
  #colors 
  color_map <- c("Upregulated" = "blue",
                 "Not Significant" = "grey30",
                 "Downregulated" = "red")
  
  #generate volcano plots
  p <- ggplot(toptable, aes(x = logFC, 
                            y = -log10(P.Value),
                            color = Significance)) +
    geom_point_rast(alpha = 0.8, size = 3) +
    scale_color_manual(values = color_map, 
                       labels = legend_lab,
                       breaks = c("Upregulated",
                                  "Not Significant", 
                                  "Downregulated"))  +
    xlim(-10,10) +
    labs(title = title, 
         x = expression("log"[2]*"FC"),
         y = expression("-log"[10]*"p-value")) +
    theme_custom() +
    theme(legend.position = "right")
  
  return(p)
}

#now generate a volcano plot for each set
volcano_plots_sig <- lapply(names(toptable_list), function(nm) {
  generate_volcano_plot(toptable_list[[nm]], title = nm)
})
names(volcano_plots_sig) <- names(toptable_list)

#display all
for (plot_name in names(volcano_plots_sig)) {
  print(volcano_plots_sig[[plot_name]])
}

#now save each of these as pdf and png files
for (plot_name in names(volcano_plots_sig)) {

  p <- volcano_plots_sig[[plot_name]]

  filename_base <- paste0("Volcano_Plot_", plot_name, "_EMP")

  save_plot(
    plot = p,
    filename = filename_base,
    folder = output_folder
  )
}

```


```{r Volcano Plots 2 and 24hr}

generate_volcano_plot <- function(toptable, title, xlim_all = c(-5, 5), ylim_all = NULL) {

  #check for Entrez_ID
  if(!"Entrez_ID" %in% colnames(toptable)) stop("Entrez_ID column not present")

  #make significance labels
  toptable <- toptable %>% 
    mutate(Significance = case_when(
      logFC > 0 & adj.P.Val < 0.05 ~ "Upregulated",
      logFC < 0 & adj.P.Val < 0.05 ~ "Downregulated",
      TRUE  ~ "Not Significant"
    ))

  #factor significance
  toptable$Significance <- factor(
    toptable$Significance, 
    levels = c("Upregulated", "Not Significant", "Downregulated")
  )

  #count genes in each category
  upgenes <- sum(toptable$Significance == "Upregulated")
  nsgenes <- sum(toptable$Significance == "Not Significant")
  downgenes <- sum(toptable$Significance == "Downregulated")

  #colors 
  color_map <- c("Upregulated" = "#003179",
                 "Not Significant" = "grey70",
                 "Downregulated" = "firebrick")


  #generate volcano plot
   p <- ggplot(toptable, aes(x = logFC, y = -log10(P.Value), color = Significance)) +
    geom_point_rast(alpha = 0.7, size = 3) +
    scale_color_manual(values = color_map) +
    coord_cartesian(xlim = c(-5, 5), ylim = c(0, 70)) +
    labs(title = title, x = expression("log"[2]*"FC"), 
         y = expression("-log"[10]*"p-value")) +
    theme_custom() +
    theme(legend.position = "none") +
    annotate("text", x = 4.8, y = 68, 
             label = paste0("Up = ", upgenes),
             color = "#003179", hjust = 1, size = 4) +
    annotate("text", x = -4.8, y = 68, 
             label = paste0("Down = ", downgenes), 
             color = "firebrick", hjust = 0, size = 4) +
    annotate("text", x = 0, y = 68, 
             label = paste0("NS = ", nsgenes), color = "grey20",
             hjust = 0.5, size = 4)
  
  return(p)
}

#print a separate legend
# example_plot <- volcano_plots_sig[[1]] +
#   theme(legend.position = "right")  # make sure it has a legend
# 
# shared_legend <- get_legend(example_plot)
# 
# # Save legend separately
# legend_plot <- ggdraw(shared_legend)
# ggsave("Volcano_24hr_Legend_EMP.png", legend_plot, width = 3, height = 4)

# Generate volcano plots for all 24hr samples
volcano_plots_sig <- lapply(names(toptable_list), function(nm) {
  generate_volcano_plot(toptable_list[[nm]], title = nm)
})
names(volcano_plots_sig) <- names(toptable_list)


# Display all plots
for (plot_name in names(volcano_plots_sig)) {
  print(volcano_plots_sig[[plot_name]])
}

# Save each plot as PDF/PNG
for (plot_name in names(volcano_plots_sig)) {
  p <- volcano_plots_sig[[plot_name]]
  filename_base <- paste0("Volcano_Plot_", plot_name, "_AllTimes_EMP")
  save_plot(plot = p, 
            filename = filename_base,
            height = 5, width = 5,
            folder = output_folder)
}

# ### --- Arrange into patchwork grids --- ###
# UPR <- c("V.TUN24_H", "V.TUN24_C", "V.THA24_H", "V.THA24_C")
# DDR <- c("V.DOX24_H", "V.DOX24_C", "V.NUTL24_H", "V.NUTL24_C")
# IMR <- c("V.LPS24_H", "V.LPS24_C", "V.TNFa24_H", "V.TNFa24_C")
# MMR <- c("V.BPA24_H", "V.BPA24_C", "V.PFOA24_H", "V.PFOA24_C")
# 
# resp_groups <- split(names(response_vec), response_vec)
# stim_order <- c("TUN", "THA", "DOX", "NUTL", "LPS", "TNFa", "BPA", "PFOA")


#Step 2: Prepare ordered list of H/C plots
# plots_ordered <- list()
# for(resp in names(resp_groups)) {
#   for(stim in stim_order) {
#     h_name <- names(volcano_plots_sig)[grepl(paste0(stim, "24_H"),
#                                              names(volcano_plots_sig))]
#     c_name <- names(volcano_plots_sig)[grepl(paste0(stim, "24_C"),
#                                              names(volcano_plots_sig))]
#     # Only add existing plots
#     plots_ordered <- c(plots_ordered,
#                        list(volcano_plots_sig[[h_name]], volcano_plots_sig[[c_name]]))
#   }
# }


# plots_ordered <- list()
# for(resp in names(resp_groups)) {
#   for(stim in resp_groups[[resp]]) {
#     h_name <- names(volcano_plots_sig)[grepl(paste0(stim, "24_H"),
#                                              names(volcano_plots_sig))]
#     c_name <- names(volcano_plots_sig)[grepl(paste0(stim, "24_C"),
#                                              names(volcano_plots_sig))]
#     
#     # Only append existing plots
#     plots_ordered <- c(plots_ordered,
#                        list(volcano_plots_sig[[h_name]], volcano_plots_sig[[c_name]]))
#   }
# }
# 
# # Step 2: Make grids using wrap_plots (no slicing)
# square_grid <- wrap_plots(plots_ordered, ncol = 4, nrow = 4)   
# # tall_grid   <- wrap_plots(plots_ordered, ncol = 8, nrow = 2)   
# # wide_grid   <- wrap_plots(plots_ordered, ncol = 2, nrow = 8)   
# 
# # Step 3: Save
# # save_plot(square_grid, "Volcano_24hr_4x4_EMP", folder = output_folder, width = 5*4, height = 5*4)
# # save_plot(tall_grid,   "Volcano_24hr_2x8_EMP", folder = output_folder, width = 5*8, height = 5*2)
# # save_plot(wide_grid,   "Volcano_24hr_8x2_EMP", folder = output_folder, width = 5*2, height = 5*8)
# 
# # Step 1: Make a temporary plot with legend only
# example_plot <- volcano_plots_sig[[1]] +
#   theme(legend.position = "right")  # show legend
# 
# shared_legend <- get_legend(example_plot)
# 
# # Step 2: Add shared legend below your grid
# square_grid_with_legend <- plot_grid(
#   square_grid,
#   shared_legend,
#   ncol = 1,  # stack vertically
#   rel_heights = c(1, 0.1)  # adjust height ratio: 0.1 for legend
# )
# 
# # tall_grid_with_legend <- plot_grid(
# #   tall_grid,
# #   shared_legend,
# #   ncol = 1,
# #   rel_heights = c(1, 0.1)
# # )
# # 
# # wide_grid_with_legend <- plot_grid(
# #   wide_grid,
# #   shared_legend,
# #   ncol = 1,
# #   rel_heights = c(1, 0.1)
# # )
# # 
# # # Step 3: Save grids with shared legend
# # save_plot(square_grid_with_legend, "Volcano_24hr_4x4_EMP_fixed_legend", folder = output_folder, width = 5*4, height = 5*4 + 0.5)
# # save_plot(tall_grid_with_legend,   "Volcano_24hr_2x8_EMP_fixed_legend", folder = output_folder, width = 5*8, height = 5*2 + 0.5)
# # save_plot(wide_grid_with_legend,   "Volcano_24hr_8x2_EMP_fixed_legend", folder = output_folder, width = 5*2, height = 5*8 + 0.5)


```



```{r Stacked Barplots DEGs vs nonDEGs}
#now I want to take the above data for 24hr only and make stacked barplots
#integrate these with my venn diagrams underneath too?


#pull out DEGs vs nonDEGs
degs_all_summary <- degs_all_bp %>%
  mutate(DE_status = ifelse(adj.P.Val < 0.05, "DE", "Not DE")) %>%
  group_by(Stimulus, DE_status) %>%
  summarise(Count = n(), .groups = "drop") %>%
  ungroup() %>%
  mutate(
    fill_color = ifelse(DE_status == "DE", "#377eb8", "grey60"),
    Species = ifelse(grepl("_H$", Stimulus), "H", "C"),
    Stim = sub("_(H|C)$", "", Stimulus)
  )

#make sure species and stim is in the correct order
stim_order <- c("TUN", "THA", "DOX", "NUTL", "LPS", "TNFa", "BPA", "PFOA")
degs_all_summary$Stim <- factor(degs_all_summary$Stim, levels = stim_order)
degs_all_summary$Species <- factor(degs_all_summary$Species, levels = c("H", "C"))

#plot all of these faceted barplots with the same x and y axis
deg_barplot_stim <- ggplot(degs_all_summary, aes(x = Species, y = Count, fill = DE_status)) +
  geom_bar(stat = "identity", color = "black", width = 0.9) +
  scale_fill_manual(
    values = c("DE" = "#377eb8", "Not DE" = "grey60"),
    name = "Gene Status"
  ) +
  facet_wrap(~Stim, nrow = 1, scales = "free_x") +
  theme_minimal(base_size = 14) +
  labs(
    x = "",
    y = "Total genes",
    title = " "
  ) +
  theme(
    strip.background = element_blank(),
    strip.text = element_text(size = 12, face = "bold"),
    axis.text.x = element_text(size = 11),
    axis.title.x = element_text(size = 14),
    axis.title.y = element_text(size = 14),
    plot.title = element_text(hjust = 0.5),
    panel.spacing = unit(1.2, "lines"),
    axis.text.y = element_text(),
    axis.ticks.y = element_line(),
    axis.line.y = element_line()
  )

#check all of the numbers of DEGs so I can manually add later
total_DEGs_table <- degs_all_summary %>%
  filter(DE_status == "DE") %>%
  group_by(Stim, Species) %>%
  summarise(DEGs = sum(Count), .groups = "drop") %>%
  arrange(factor(Stim, levels = stim_order), Species)


# Print table
print(total_DEGs_table)

save_plot(plot = deg_barplot_stim,
          filename = "Stacked_Barplot_DEGs_EMP_",
          folder = output_folder,
          height = 6, 
          width = 12)

```



```{r}
library(dplyr)
library(ggplot2)

# Summarize DE vs Not DE counts
degs_all_summary <- degs_all_bp %>%
  mutate(DE_status = ifelse(adj.P.Val < 0.05, "DE", "Not DE")) %>%
  group_by(Stimulus, Stim, Species, DE_status) %>%
  summarise(Count = n(), .groups = "drop") %>%
  ungroup() %>%
  mutate(
    # For fill: DE = stimulus color, Not DE = gray
    fill_color = ifelse(DE_status == "DE", stim_col[Stim], "grey60")
  )

# Factor ordering
stimspec_order <- c("TUN_H", "TUN_C", 
                    "THA_H", "THA_C",
                    "DOX_H", "DOX_C",
                    "NUTL_H", "NUTL_C",
                    "LPS_H", "LPS_C",
                    "TNFa_H", "TNFa_C",
                    "BPA_H", "BPA_C",
                    "PFOA_H", "PFOA_C")
degs_all_summary$Stimulus <- factor(degs_all_summary$Stimulus, levels = stimspec_order)

# Create a separate column for stimulus legend
degs_all_summary$Stim_for_legend <- factor(degs_all_summary$Stim, levels = names(stim_col))

# Plot
ggplot(degs_all_summary, aes(x = Stimulus, y = Count, fill = fill_color)) +
  geom_bar(stat = "identity", position = "stack", color = "black") +
  # Add DE counts on top of DE bars
  geom_text(
    data = degs_all_summary %>% filter(DE_status == "DE"),
    aes(label = Count),
    position = position_stack(vjust = 0.5),
    color = "white",
    size = 3.5
  ) +
  # Custom fill scale with identity for actual colors
  scale_fill_identity(
    name = "Status / Stimulus",
    guide = "legend",
    labels = c("Not DE", names(stim_col)),
    breaks = c("grey60", stim_col)
  ) +
  theme_custom() +
  labs(
    x = "Stimulus",
    y = "# of genes",
    title = "DE (significant) vs Not DE genes"
  ) +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1)
  )

```

#Add SYMBOL column
```{r Add HGNC Symbol to each toptable}
#in order to plot the logFC heatmaps, I want to add a SYMBOL column to each of my toptables based on their Entrez_ID

#make a loop to do this since it might take a while
# toptable_list <- lapply(toptable_list, function(tt) {
#   tt <- tt %>% 
#     mutate(
#       Entrez_ID = rownames(tt),
#       SYMBOL = mapIds(org.Hs.eg.db, 
#                       keys = Entrez_ID,
#                       column = "SYMBOL",
#                       keytype = "ENTREZID",
#                       multiVals = "first")
#     )
#   rownames(tt) <- NULL
#   
#   return(tt)
# })

#resave your toptable list so you can keep the symbol col
# saveRDS(toptable_list, "data/de/Toptable_list_entrez.RDS")

#read in your new toptable_list
toptable_list <- readRDS("data/de/Toptable_list_entrez.RDS")

```

#DEGs
```{r Specify your DEGs lists}
#loop through and save my toptable csvs into easier names to maneuver for later analysis - ie Toptable_V.TUN2_C into TUN2_C

#first save all of the toptables that now have entrez and symbol as csv in my DEGs folder

# output <- "data/de/DEGs"
# 
# #save all data frames in toptable_list to csv
# walk2(toptable_list, names(toptable_list), ~ {
#   file_path <- file.path(output, paste0("Toptable_", .y, ".csv"))
#   write.csv(.x, file_path, row.names = FALSE)
#   message("Saved: ", file_path)
# })

#all of the csvs are saved

#now create a load_deg function to load them as needed from this path
load_deg <- function(name, folder = "data/de/DEGs") {
  file <- file.path(folder, paste0("Toptable_V.", name, ".csv"))
  read.csv(file)
}

```

```{r Define gene sets for later analysis}
#define your gene sets DIC and DDR

#here is the set with categories, symbol, and entrezid
fonoudi_genes <- readRDS("data/genesets/Fonoudi_gene_set.RDS")
ddr_genes <- readRDS("data/genesets/DDR_gene_set.RDS")
dic_genes <- readRDS("data/genesets/DIC_genes_set.RDS")

#here are the ids where it's only a vector of Entrez_ID
fonoudi_ids <- readRDS("data/genesets/Fonoudi_genes_entrezid.RDS")
ddr_ids <- readRDS("data/genesets/DDR_genes_entrezid.RDS")
dic_ids <- readRDS("data/genesets/DIC_genes_entrezid.RDS")

```

##logFC Heatmaps
```{r logFC HM DDR DIC 24hr}

# toptable_24hr_names <- names(toptable_list)[grepl("24", names(toptable_list))]
# 
# toptable_list_24 <- toptable_list[toptable_24hr_names]

# saveRDS(toptable_list_24, "data/de/Toptable_list_24hr.RDS")

#read in my toptable list for 24hr
toptable_list_24 <- readRDS("data/de/Toptable_list_24hr.RDS")

#read in my gene sets
ddr_genes
fonoudi_genes

#read in colors
spec_col <- readRDS("data/theme/species_category_color_palette.RDS")
stim_col <- readRDS("data/theme/stimulus_color_palette_all.RDS")
ddr_col <- c("DOX" = "#3B4DA3", "NUTL" = "#A0CFF8")
ind_col <- readRDS("data/theme/individual_category_color_palette.RDS")

#make my ddr heatmap


```

#DDR logFC HM
```{r logFC HM DDR genes 24hr DOX NUTL}
# Load 24hr DEGs
DOX_24_H <- read.csv("data/de/Toptable_V.DOX24_H.csv")
DOX_24_C <- read.csv("data/de/Toptable_V.DOX24_C.csv")
NUTL_24_H <- read.csv("data/de/Toptable_V.NUTL24_H.csv")
NUTL_24_C <- read.csv("data/de/Toptable_V.NUTL24_C.csv")

#I named them without the time since I don't want that annotated onto the heatmaps

# DDR gene set (with categories and Entrez IDs)
ddr_genes <- readRDS("data/genesets/DDR_gene_set.RDS")

ddr_genes <- ddr_genes %>% 
  mutate(Entrez_ID = as.character(Entrez_ID))

ddr_ids <- readRDS("data/genesets/DDR_genes_entrezid.RDS") %>% 
  as.character()

# Metadata table (columns: Final_sample_name, Stimulus, Species, Individual)
metadata_24 <- metadata %>% 
  dplyr::filter(Time == "24")

#extract relevant DEG values
extract_data_DDR <- function(df, name) {
  df %>%
    filter(Entrez_ID %in% ddr_ids) %>%
    mutate(
      Gene = mapIds(org.Hs.eg.db, 
                    as.character(Entrez_ID),
                    column = "SYMBOL", 
                    keytype = "ENTREZID", 
                    multiVals = "first"),
      Condition = name,
      Signif = ifelse(adj.P.Val < 0.05, "*", "")
    )
}

deg_list_ddr24 <- list("DOX_H" = DOX_24_H, 
                       "NUTL_H" = NUTL_24_H, 
                       "DOX_C" = DOX_24_C,
                       "NUTL_C" = NUTL_24_C
)

deg_list_ddr24 <- lapply(deg_list_ddr24, function(df) {
  df %>% mutate(Entrez_ID = as.character(Entrez_ID))
})

all_data_ddr <- bind_rows(mapply(extract_data_DDR, deg_list_ddr24, names(deg_list_ddr24), SIMPLIFY = FALSE)) %>% 
  left_join(ddr_genes, by = "Entrez_ID")

#create my matrices
logFC_matddr <- acast(all_data_ddr, Gene ~ Condition, value.var = "logFC")
signif_matddr <- acast(all_data_ddr, Gene ~ Condition, value.var = "Signif")

#set desired order
desired_order <- c("DOX_H", "DOX_C", "NUTL_H", "NUTL_C")

logFC_mat_ddr <- logFC_matddr[, desired_order, drop = FALSE]
signif_mat_ddr <- signif_matddr[, desired_order, drop = FALSE]

#make column annotations (stimuli species)
meta_ddr <- str_split_fixed(colnames(logFC_mat_ddr), "_", 2)

col_annot <- HeatmapAnnotation(
  Stimulus = meta_ddr[, 1],
  Species = meta_ddr[, 2],
  col = list(
    Stimulus = ddr_col,
    Species = spec_col
  ),
  annotation_height = unit(c(1, 1, 1), "cm")
)

#row annotation (categories)
gene_order_df_ddr <- all_data_ddr %>% 
  distinct(Gene, Category) %>% 
  arrange(factor(Category, 
                 levels = sort(unique(ddr_genes$Category))), Gene)

ordered_genes_ddr <- gene_order_df_ddr$Gene
logFC_mat_ddr <- logFC_mat_ddr[ordered_genes_ddr, ]
signif_mat_ddr <- signif_mat_ddr[ordered_genes_ddr, ]

category_levels <- sort(unique(ddr_genes$Category))

category_cols_ddr <- setNames(
  c("darkorange", "steelblue", "darkgreen", "firebrick",
    "orchid", "mediumpurple"),
  sort(unique(ddr_genes$Category))
)

ha_left_ddr <- rowAnnotation(
  Category = gene_order_df_ddr$Category,
  col = list(Category = category_cols_ddr),
  annotation_name_side = "top"
)

#plot the heatmap
DDR_logFC_HM <- Heatmap(logFC_mat_ddr,
        name = "logFC",
        top_annotation = col_annot,
        left_annotation = ha_left_ddr,
        cluster_columns = FALSE,
        cluster_rows = FALSE,
        show_row_names = TRUE,
        show_column_names = FALSE,
        row_names_gp = gpar(fontsize = 10),
        column_title = "DDR Genes logFC HM",
        column_title_gp = gpar(fontsize = 12),
        cell_fun = function(j, i, x, y, width, height, fill) {
          #draw a black border
          grid.rect(x = x, y = y, width = width, height = height,
                    gp = gpar(col = "black", lwd = 0.5, fill = fill))
          #add significance for DEGs
          grid.text(signif_mat_ddr[i,j], x, y, gp = gpar(fontsize = 10))
        })

#save this as a pdf and png
#make a function specifically to save ComplexHeatmaps since save_plot doesn't work with these

save_complex_heatmap <- function(ht, filename, folder = ".", width = 6, height = 10, dpi = 300, add_date = TRUE) {
  if (missing(filename)) stop("Please provide a filename (without extension) for the plot.")
  
  date_str <- if (add_date) paste0("_", format(Sys.Date(), "%y%m%d")) else ""
  
  pdf_file <- file.path(folder, paste0(filename, date_str, ".pdf"))
  png_file <- file.path(folder, paste0(filename, date_str, ".png"))
  
  # Save PDF
  cairo_pdf(pdf_file, width = width, height = height)
  draw(ht)
  dev.off()
  message("Saved PDF: ", pdf_file)
  
  # Save PNG
  png(png_file, width = width, height = height, units = "in", res = dpi)
  draw(ht)
  dev.off()
  message("Saved PNG: ", png_file)
}

print(DDR_logFC_HM)

#now save my heatmap
# save_complex_heatmap(DDR_logFC_HM, 
#                      "DDR_logFC_HM_EMP", 
#                      folder = output_folder)


```


#DOX Cardiotox logFC HM
```{r Dox Cardiotox Fonoudi genes logFC HM}
# Load 24hr DEGs
DOX_24_H <- read.csv("data/de/Toptable_V.DOX24_H.csv")
DOX_24_C <- read.csv("data/de/Toptable_V.DOX24_C.csv")
NUTL_24_H <- read.csv("data/de/Toptable_V.NUTL24_H.csv")
NUTL_24_C <- read.csv("data/de/Toptable_V.NUTL24_C.csv")

#I named them without the time since I don't want that annotated onto the heatmaps

# DDR gene set (with categories and Entrez IDs)
fnd_genes <- readRDS("data/genesets/Fonoudi_gene_set.RDS")

fnd_genes <- fnd_genes %>% 
  mutate(Entrez_ID = as.character(Entrez_ID))

fnd_ids <- readRDS("data/genesets/Fonoudi_genes_entrezid.RDS") %>% 
  as.character()

# Metadata table (columns: Final_sample_name, Stimulus, Species, Individual)
metadata_24 <- metadata %>% 
  dplyr::filter(Time == "24")

#extract relevant DEG values
extract_data_fnd <- function(df, name) {
  df %>%
    filter(Entrez_ID %in% fnd_ids) %>%
    mutate(
      Gene = mapIds(org.Hs.eg.db, 
                    as.character(Entrez_ID),
                    column = "SYMBOL", 
                    keytype = "ENTREZID", 
                    multiVals = "first"),
      Condition = name,
      Signif = ifelse(adj.P.Val < 0.05, "*", "")
    )
}

deg_list_fnd24 <- list("DOX_H" = DOX_24_H, 
                       "NUTL_H" = NUTL_24_H, 
                       "DOX_C" = DOX_24_C,
                       "NUTL_C" = NUTL_24_C
)

deg_list_fnd24 <- lapply(deg_list_fnd24, function(df) {
  df %>% mutate(Entrez_ID = as.character(Entrez_ID))
})

all_data_fnd <- bind_rows(mapply(extract_data_fnd, deg_list_fnd24, names(deg_list_fnd24), SIMPLIFY = FALSE)) %>% 
  left_join(fnd_genes, by = "Entrez_ID")

#create my matrices
logFC_matfnd <- acast(all_data_fnd, Gene ~ Condition, value.var = "logFC")
signif_matfnd <- acast(all_data_fnd, Gene ~ Condition, value.var = "Signif")

#set desired order
desired_order <- c("DOX_H", "DOX_C", "NUTL_H", "NUTL_C")

logFC_mat_fnd <- logFC_matfnd[, desired_order, drop = FALSE]
signif_mat_fnd <- signif_matfnd[, desired_order, drop = FALSE]

#make column annotations (stimuli species)
meta_fnd <- str_split_fixed(colnames(logFC_mat_fnd), "_", 2)

col_annot <- HeatmapAnnotation(
  Stimulus = meta_fnd[, 1],
  Species = meta_fnd[, 2],
  col = list(
    Stimulus = ddr_col,
    Species = spec_col
  ),
  annotation_height = unit(c(1, 1, 1), "cm")
)

#row annotation (categories)
gene_order_df_fnd <- all_data_fnd %>% 
  distinct(Gene, Category) %>% 
  arrange(factor(Category, 
                 levels = sort(unique(fnd_genes$Category))), Gene)

ordered_genes_fnd <- gene_order_df_fnd$Gene
logFC_mat_fnd <- logFC_mat_fnd[ordered_genes_fnd, ]
signif_mat_fnd <- signif_mat_fnd[ordered_genes_fnd, ]

category_levels <- sort(unique(fnd_genes$Category))

category_cols_fnd <- setNames(
  c("darkorange", "steelblue", "darkgreen", "firebrick",
    "orchid", "mediumpurple",  "gold"),
  sort(unique(fnd_genes$Category))
)

ha_left_fnd <- rowAnnotation(
  Category = gene_order_df_fnd$Category,
  col = list(Category = category_cols_fnd),
  annotation_name_side = "top"
)

#plot the heatmap
FND_logFC_HM <- Heatmap(logFC_mat_fnd,
        name = "logFC",
        top_annotation = col_annot,
        left_annotation = ha_left_fnd,
        cluster_columns = FALSE,
        cluster_rows = FALSE,
        show_row_names = TRUE,
        show_column_names = FALSE,
        row_names_gp = gpar(fontsize = 10),
        column_title = "Fonoudi Genes logFC HM",
        column_title_gp = gpar(fontsize = 12),
        cell_fun = function(j, i, x, y, width, height, fill) {
          #draw a black border
          grid.rect(x = x, y = y, width = width, height = height,
                    gp = gpar(col = "black", lwd = 0.5, fill = fill))
          #add significance for DEGs
          grid.text(signif_mat_fnd[i,j], x, y, gp = gpar(fontsize = 10))
        })

print(FND_logFC_HM)

#now save my heatmap
# save_complex_heatmap(FND_logFC_HM, 
#                      "FND_logFC_HM_EMP", 
#                      folder = output_folder)


```


```{r DIC logFC HM}
#read in list of genes in DIC gene set (from Matthews et al., 2021)
dic_genes <- readRDS("data/genesets/DIC_genes_set.RDS")
dic_ids <- readRDS("data/genesets/DIC_genes_entrezid.RDS")

# Load 24hr DEGs
DOX_24_H <- read.csv("data/de/Toptable_V.DOX24_H.csv")
DOX_24_C <- read.csv("data/de/Toptable_V.DOX24_C.csv")
NUTL_24_H <- read.csv("data/de/Toptable_V.NUTL24_H.csv")
NUTL_24_C <- read.csv("data/de/Toptable_V.NUTL24_C.csv")

#I named them without the time since I don't want that annotated onto the heatmaps

# DDR gene set (with categories and Entrez IDs)
dic_genes <- dic_genes %>% 
  mutate(Entrez_ID = as.character(Entrez_ID))

dic_ids <- readRDS("data/genesets/DIC_genes_entrezid.RDS") %>% 
  as.character()

# Metadata table (columns: Final_sample_name, Stimulus, Species, Individual)
metadata_24 <- metadata %>% 
  dplyr::filter(Time == "24")

#extract relevant DEG values
extract_data_dic <- function(df, name) {
  df %>%
    filter(Entrez_ID %in% dic_ids) %>%
    mutate(
      Gene = mapIds(org.Hs.eg.db, 
                    as.character(Entrez_ID),
                    column = "SYMBOL", 
                    keytype = "ENTREZID", 
                    multiVals = "first"),
      Condition = name,
      Signif = ifelse(adj.P.Val < 0.05, "*", "")
    )
}

deg_list_dic24 <- list("DOX_H" = DOX_24_H, 
                       "NUTL_H" = NUTL_24_H, 
                       "DOX_C" = DOX_24_C,
                       "NUTL_C" = NUTL_24_C
)

deg_list_dic24 <- lapply(deg_list_dic24, function(df) {
  df %>% mutate(Entrez_ID = as.character(Entrez_ID))
})

all_data_dic <- bind_rows(mapply(extract_data_dic, deg_list_dic24, names(deg_list_dic24), SIMPLIFY = FALSE)) %>% 
  left_join(dic_genes, by = "Entrez_ID")

#create my matrices
logFC_matdic <- acast(all_data_dic, Gene ~ Condition, value.var = "logFC")
signif_matdic <- acast(all_data_dic, Gene ~ Condition, value.var = "Signif")

#set desired order
desired_order <- c("DOX_H", "DOX_C", "NUTL_H", "NUTL_C")

logFC_mat_dic <- logFC_matdic[, desired_order, drop = FALSE]
signif_mat_dic <- signif_matdic[, desired_order, drop = FALSE]

#make column annotations (stimuli species)
meta_dic <- str_split_fixed(colnames(logFC_mat_dic), "_", 2)

col_annot <- HeatmapAnnotation(
  Stimulus = meta_dic[, 1],
  Species = meta_dic[, 2],
  col = list(
    Stimulus = ddr_col,
    Species = spec_col
  ),
  annotation_height = unit(c(2, 2, 2), "cm")
)

#don't need row annotation for this set, no categories

#plot the heatmap
DIC_logFC_HM <- Heatmap(logFC_mat_dic,
        name = "log2FC",
        top_annotation = col_annot,
        cluster_columns = FALSE,
        cluster_rows = TRUE,
        show_row_names = TRUE,
        show_column_names = FALSE,
        show_row_dend = FALSE,
        show_column_dend = FALSE,
        row_names_gp = gpar(fontsize = 14),
        column_title = "DIC Genes logFC HM",
        column_title_gp = gpar(fontsize = 14),
        column_names_gp = gpar(fontsize = 14),
        cell_fun = function(j, i, x, y, width, height, fill) {
          #draw a black border
          grid.rect(x = x, y = y, width = width, height = height,
                    gp = gpar(col = "black", lwd = 1, fill = fill))
          #add significance for DEGs
          grid.text(signif_mat_dic[i,j], x, y, gp = gpar(fontsize = 14))
        },
        width = unit(3, "in"), 
        height = unit(8, "in")
        )

print(DIC_logFC_HM)

#now save my heatmap
save_complex_heatmap(DIC_logFC_HM,
                     "DIC_logFC_HM_EMP",
                     folder = output_folder)


```


#Treatment Comparisons
```{r Compare DEGs Venn Diagrams}
#make comparisons across all 2 + 24hr pairwise treatment DEGs
#venn diagram 

stimuli <- c("TUN2", "THA2", "DOX2", "NUTL2",
             "LPS2", "TNFa2", "BPA2", "PFOA2",
             "TUN24", "THA24", "DOX24", "NUTL24",
             "LPS24", "TNFa24", "BPA24", "PFOA24")

#loop through the defined treatments
for (st in stimuli) {
  
  #make object names
  nm_H <- paste0("V.", st, "_H")
  nm_C <- paste0("V.", st, "_C")
  
  #skip if not in the toptable list for DEGs
  if (!(nm_H %in% names(toptable_list)) & !(nm_C %in% names(toptable_list))) {
    message("skipping", st, "- no DEGs H and C")
    next
  }
  
  h_genes <- if (nm_H %in% names(toptable_list)) {
    df_h <- toptable_list[[nm_H]]
    df_h$Entrez_ID <- as.character(df_h$Entrez_ID)
    df_h$Entrez_ID[!is.na(df_h$adj.P.Val) & df_h$adj.P.Val < 0.05]
  } else character(0)
  
  c_genes <- if (nm_C %in% names(toptable_list)) {
    df_c <- toptable_list[[nm_C]]
    df_c$Entrez_ID <- as.character(df_c$Entrez_ID)
    df_c$Entrez_ID[!is.na(df_c$adj.P.Val) & df_c$adj.P.Val < 0.05]
  }
  
  # #pull DEGs by filtering for adj.p < 0.05
  deg_H <- toptable_list[[nm_H]] %>%
    dplyr::filter(adj.P.Val < 0.05) %>%
    pull(Entrez_ID)
  deg_C <- toptable_list[[nm_H]] %>%
    dplyr::filter(adj.P.Val < 0.05) %>%
    pull(Entrez_ID)

  #if both empty - skip
  if (length(h_genes) == 0 & length(c_genes) == 0) {
    message("skipping", st, "- no DEGs H and C")
    next
  }
  
  #create venn list
  venn_list <- list(
    H = h_genes,
    C = c_genes
  )
  
  #fit proportional venn
  fit <- euler(venn_list, shape = "ellipse")
  
  #plot proportional venn
  plot_title <- paste0("DEGs H vs C - ", st)
  p <- plot(fit,
       fills = list(fill = c("#740949", "#A6AA59"), alpha = 0.6),
       labels = TRUE,
       quantities = TRUE, 
       main = plot_title
       )
  
  print(p)
  
}
  
  # #save as png and pdf in my output_folder
#   png_filename <- file.path(output_folder,
#                             paste0("PropVenn_", st, "_EMP_251010.png"))
#   png(png_filename, width = 6, height = 6, units = "in", res = 300)
#   print(
#     plot(fit,
#        fills = list(fill = c("#740949", "#A6AA59"), alpha = 0.6),
#        labels = TRUE,
#        quantities = TRUE,
#        main = plot_title
#   )
#   )
#   dev.off()
# 
#   pdf_filename <- file.path(output_folder,
#                             paste0("PropVenn_", st, "_EMP_251010.pdf"))
#   cairo_pdf(pdf_filename, width = 6, height = 6)
#   print(
#     plot(fit,
#        fills = list(fill = c("#740949", "#A6AA59"), alpha = 0.6),
#        labels = TRUE,
#        quantities = TRUE,
#        main = plot_title
#   )
#   )
#   dev.off()
# 
#   message("Saved Euler diagram for ", st)
# 
# }


```

#Timepoint Comparison Venn
```{r Timepoint comparison Venn Diagrams}
#now use the same workflow as above to create Venn diagrams to compare DEGs by timepoint within a species and stimulus

stimuli <- c("TUN", "THA", "DOX", "NUTL", "LPS", "TNFa", "BPA", "PFOA")
timepoints <- c("2", "24")

#make a loop to go through all stimuli per timepoint
for (stim in stimuli) {
  for (sp in c("H", "C")) {
    
    # Define timepoint object names
    nm_2hr  <- paste0("V.", stim, "2", "_", sp)
    nm_24hr <- paste0("V.", stim, "24", "_", sp)
    
    # Skip if neither timepoint exists
    if (!(nm_2hr %in% names(toptable_list)) &
        !(nm_24hr %in% names(toptable_list))) {
      message("Skipping ", stim, " (", sp, ") â€” no DEGs for either timepoint.")
      next
    }
    
    # Pull DEGs for each timepoint
    genes_2hr <- if (nm_2hr %in% names(toptable_list)) {
      toptable_list[[nm_2hr]] %>%
        filter(!is.na(adj.P.Val) & adj.P.Val < 0.05) %>%
        pull(Entrez_ID) %>%
        as.character()
    } else character(0)
    
    genes_24hr <- if (nm_24hr %in% names(toptable_list)) {
      toptable_list[[nm_24hr]] %>%
        filter(!is.na(adj.P.Val) & adj.P.Val < 0.05) %>%
        pull(Entrez_ID) %>%
        as.character()
    } else character(0)
    
    # Skip if both empty
    if (length(genes_2hr) == 0 & length(genes_24hr) == 0) {
      message("Skipping ", stim, " (", sp, ") â€” no DEGs for 2hr or 24hr.")
      next
    }
    
    # Create venn list
    venn_list <- list(
      "2hr" = genes_2hr,
      "24hr" = genes_24hr
    )
    
    # Fit and plot
    fit <- euler(venn_list, shape = "ellipse")
    plot_title <- paste0(stim, " (", sp, ") â€” 2hr vs 24hr DEGs")
    
    p <- plot(fit,
              fills = list(fill = c("#F6B4B4", "#9DC4E4"), alpha = 0.6),
              labels = list(font = 1),
              quantities = TRUE,
              main = plot_title)
    
    # Define filenames
png_filename <- file.path(output_folder,
                          paste0("PropVenn_Timepoint_", stim, "_", sp, "_EMP_251111.png"))
pdf_filename <- file.path(output_folder,
                          paste0("PropVenn_Timepoint_", stim, "_", sp, "_EMP_251111.pdf"))

# Recreate the plot object
plot_title <- paste0(stim, " â€” 2hr vs 24hr DEGs (", sp, ")")
p <- plot(
  fit,
  fills = list(fill = c("pink", "blue"), alpha = 0.6),
  labels = TRUE,
  quantities = TRUE,
  main = plot_title
)

# Save as PNG
png(png_filename, width = 6, height = 6, units = "in", res = 300)
plot(
  fit,
  fills = list(fill = c("pink", "blue"), alpha = 0.6),
  labels = TRUE,
  quantities = TRUE,
  main = plot_title
)
dev.off()

# Save as PDF (using cairo for text rendering)
cairo_pdf(pdf_filename, width = 6, height = 6)
plot(
  fit,
  fills = list(fill = c("pink", "blue"), alpha = 0.6),
  labels = TRUE,
  quantities = TRUE,
  main = plot_title
)
dev.off()

message("saved venn for ", stim, " (", sp, ") at 2hr and 24hr.")

  }
}




```


```{r Scatterplots logFC All Treatments 24hr}
#read in my toptable_list_24
toptable_list_24 <- readRDS("data/de/Toptable_list_24hr.RDS")

toptable_list_24 <- lapply(toptable_list_24, function(df) {
  df %>% mutate(Entrez_ID = as.character(Entrez_ID))
})

#define stimuli
stimuli <- c("TUN24", "THA24", "DOX24", "NUTL24",
             "LPS24", "TNFa24", "BPA24", "PFOA24")

#store correlation data
spearman_results <- data.frame(
  Stimulus = character(),
  Spearman_rho = numeric(),
  pvalue = numeric(),
  stringsAsFactors = FALSE
)


for (st in stimuli) {
  #make object names
  nm_H <- paste0("V.", st, "_H")
  nm_C <- paste0("V.", st, "_C")
  
  #skip if not in the toptable list for DEGs
  if (!(nm_H %in% names(toptable_list_24)) & !(nm_C %in% names(toptable_list_24))) {
    message("skipping", st, "- no H and C found")
    next
  }
  
  #pull my data and default to empty tibble if missing
  df_h <- toptable_list_24[[nm_H]] %>% 
    mutate(Entrez_ID = as.character(Entrez_ID))
  
  df_c <- toptable_list_24[[nm_C]] %>% 
    mutate(Entrez_ID = as.character(Entrez_ID))

  
  merged_df <- data.frame(
    Entrez_ID = df_h$Entrez_ID,
    logFC_H = as.numeric(df_h$logFC),
    logFC_C = as.numeric(df_c$logFC)
  )
  
  #calculate spearman correlation and plot rho on plot
  cor_test <- cor.test(merged_df$logFC_H, merged_df$logFC_C, 
                       method = "spearman")
  rho <- round(cor_test$estimate, 3)
  pval <- ifelse(cor_test$p.value < 0.001, "<0.001",
                 round(cor_test$p.value, 3))
  cor_label <- paste0("rho = ", rho, "\n", "p = ", pval)
  
  spearman_results <- rbind(spearman_results,
                            data.frame(Stimulus = st,
                                       Rho = rho,
                                       pvalue = cor_test$p.value))
  
  stim_name <- sub("24.*", "", st)
  point_color <- ifelse(stim_name %in% names(stim_col),
                        stim_col[stim_name], "gray50")
  
  #plot scatterplots
  #use fixed coordinates for same visual scale
  p <- ggplot(merged_df, aes(x = logFC_H, y = logFC_C)) +
    rasterize(geom_point(color = point_color), dpi = 300) +
    geom_abline(slope = 1, intercept = 0, 
                linetype = "dashed", color = "black", lwd = 1) +
    coord_fixed(xlim = c(-9, 9),
                ylim = c(-9, 9)) +
    labs(title = paste0("logFC H vs C - ", st),
         x = expression(log[2]*"FC H"),
         y = expression(log[2]*"FC C")
    ) +
    annotate("text", x = -8.5, y = 8.5, label = cor_label,
             hjust = 0, vjust = 1, size = 4) +
    theme_custom()
  
  print(p)
  
  # Save using your save_plot function
  # filename_base <- paste0("logFC_scatter_", st, "_EMP")
  # save_plot(plot = p,
  #           filename = filename_base,
  #           folder = output_folder)
  # 
  # message("Saved scatterplot for ", st)
  # 
}

print(spearman_results)

```


#Species Specific Genes
```{r Identify Species-Specific genes from logFC}
#I want to take my dataset and identify whether genes are responding in one species, both species, or neither species

#read in toptable list at 24hr and filter down to DOX and NUTL only
# toptable_list_24

toptable_list_ddr_24 <- toptable_list_24[grepl("DOX|NUTL", names(toptable_list_24))]

#pull out the factors I'm interested in for now
ddr_stim <- c("DOX", "NUTL")
species <- c("H", "C")

#read in my two gene sets that I want to assess the response in across species from the heatmaps above
gene_sets_ddr <- list(
  ddr = ddr_ids,
  dtox = fonoudi_ids
)

#now make a function to extract logFC and adj.P.Val for each
extract_species_df <- function(stim, sp) {
  #make object names
  nm <- paste0("V.", stim, "24_", sp)
  
  if(!nm %in% names(toptable_list_ddr_24)) {
    stop(paste("Table not found: ", nm))
  }

  df <- toptable_list_ddr_24[[nm]] %>% 
    dplyr::select(Entrez_ID, logFC, adj.P.Val) %>% 
    mutate(
      Entrez_ID = as.character(Entrez_ID),
      logFC = as.character(logFC),
      adj.P.Val = as.numeric(adj.P.Val)
    )
  
  #add a suffix for species and stimulus
  colnames(df)[2:3] <- paste0(colnames(df)[2:3], "_", sp)
  return(df)
}

#now extract your four datasets
DOX_H <- extract_species_df("DOX", "H")
DOX_C <- extract_species_df("DOX", "C")
NUTL_H <- extract_species_df("NUTL", "H")
NUTL_C <- extract_species_df("NUTL", "C")

#merge datasets by Entrez_ID
merged_ddr <- DOX_H %>% 
  left_join(DOX_C, by = "Entrez_ID") %>% 
  left_join(NUTL_H, by = "Entrez_ID") %>% 
  left_join(NUTL_C, by = "Entrez_ID")


#add tags for degs based on sig adj.P.Val < 0.05
merged_ddr <- merged_ddr %>% 
  mutate(
    sig_H_DOX = adj.P.Val_H.x < 0.05, #add .x from merge
    sig_C_DOX = adj.P.Val_C.x < 0.05,
    sig_H_NUTL = adj.P.Val_H.y < 0.05, #add .y from merge
    sig_C_NUTL = adj.P.Val_C.y < 0.05
  )


#add response direction
merged_ddr <- merged_ddr %>% 
  mutate(
    Dir_H_DOX = case_when(
      sig_H_DOX & logFC_H.x > 0 ~ "Up",
      sig_H_DOX & logFC_H.x < 0 ~ "Down",
      TRUE ~ "NR"
    ),
    Dir_C_DOX = case_when(
      sig_C_DOX & logFC_C.x > 0 ~ "Up",
      sig_C_DOX & logFC_C.x < 0 ~ "Down",
      TRUE ~ "NR"
    ),
    Dir_H_NUTL = case_when(
      sig_H_NUTL & logFC_H.y > 0 ~ "Up",
      sig_H_NUTL & logFC_H.y < 0 ~ "Down",
      TRUE ~ "NR"
    ),
    Dir_C_NUTL = case_when(
      sig_C_NUTL & logFC_C.y > 0 ~ "Up",
      sig_C_NUTL & logFC_C.y < 0 ~ "Down",
      TRUE ~ "NR"
    )
  )

#classify response patterns between species to find species-specific deg
classify_response <- function(df, col_H, col_C) {
  case_when(
    df[[col_H]] == "NR" & df[[col_C]] == "NR" ~ "NR",
    df[[col_H]] != "NR" & df[[col_C]] != "NR" & 
      df [[col_H]] == df[[col_C]] ~ "Conserved",
    df[[col_H]] != "NR" & df[[col_C]] != "NR" &
      df[[col_H]] != df[[col_C]] ~ "Divergent",
    df[[col_H]] != "NR" & df[[col_C]] == "NR" ~ "H_specific",
    df[[col_H]] == "NR" & df[[col_C]] != "NR" ~ "C_specific",
    TRUE ~ "Other"
  )
}

merged_ddr <- merged_ddr %>% 
  mutate(
    Response_DOX = classify_response(., 
                                     "Dir_H_DOX",
                                     "Dir_C_DOX"),
    Response_NUTL = classify_response(., 
                                      "Dir_H_NUTL",
                                      "Dir_C_NUTL")
  )

#make my merged table and save as csv
# write.csv(merged_ddr, "data/de/DDR_DTOX_24hr_Species_Responses_AllGenes_EMP_251003.csv",
#           row.names = FALSE)

#get the column SYMBOL in there since it's easy to map it to there
# identical(merged_ddr$Entrez_ID, toptable_list_24$V.TUN24_H$Entrez_ID)
#TRUE

# merged_ddr$SYMBOL <- toptable_list_24$V.TUN24_H$SYMBOL

#now subset your data to find only those that are DE
full_ddr <- merged_ddr

deg_ddr_24 <- full_ddr %>% 
  dplyr::filter(
    sig_H_DOX | sig_C_DOX | sig_H_NUTL | sig_C_NUTL
  )

# saveRDS(deg_resp_ddr, "DDR_DEGs_direction.RDS")

```



```{r Species Specific logFC Scatterplots}

#define stimuli
ddr_stim <- c("DOX", "NUTL")

spearman_res <- data.frame(
  Stimulus = character(),
  Rho = numeric(),
  pvalue = numeric(),
  stringsAsFactors = FALSE
)

plots <- list()

for (st in ddr_stim) {
  # Make object names
  nm_H <- paste0("V.", st, "24_H")
  nm_C <- paste0("V.", st, "24_C")
  
  if (!(nm_H %in% names(toptable_list_24)) | !(nm_C %in% names(toptable_list_24))) {
    message("Skipping ", st, " (missing H or C)")
    next
  }
  
  df_h <- toptable_list_24[[nm_H]] %>% 
    mutate(Entrez_ID = as.character(Entrez_ID))
  df_c <- toptable_list_24[[nm_C]] %>% 
    mutate(Entrez_ID = as.character(Entrez_ID))
  
  # Merge by Entrez ID
  merged_df <- data.frame(
    Entrez_ID = df_h$Entrez_ID,
    logFC_H = as.numeric(df_h$logFC),
    logFC_C = as.numeric(df_c$logFC)
  )
  
  # Identify opposite-direction genes
  merged_df <- merged_df %>%
    mutate(OppositeDir = case_when(
      logFC_H > 0 & logFC_C < 0 ~ "Opposite",
      logFC_H < 0 & logFC_C > 0 ~ "Opposite",
      TRUE ~ "Same"
    ))
  
  n_opposite <- sum(merged_df$OppositeDir == "Opposite")
  
  # Spearman correlation
  cor_test <- cor.test(merged_df$logFC_H, merged_df$logFC_C, method = "spearman")
  rho <- round(cor_test$estimate, 2)
  pval <- ifelse(cor_test$p.value < 0.001, "<0.001", round(cor_test$p.value, 3))
  cor_label <- paste0("rho = ", rho, "\n", "p = ", pval)
  
  spearman_res <- rbind(spearman_res,
                            data.frame(Stimulus = st,
                                       Rho = rho,
                                       pvalue = cor_test$p.value))
  
  stim_name <- gsub("24$", "", st)
  stim_color <- ifelse(stim_name %in% names(stim_col), stim_col[stim_name], "purple")
  
  # Scatterplot
  p <- ggplot(merged_df, aes(x = logFC_H, y = logFC_C)) +
    rasterise(geom_point(data = merged_df %>% filter(OppositeDir == "Same"),
                         color = "black", alpha = 0.5, size = 0.8), dpi = 300) +
    rasterise(geom_point(data = merged_df %>% filter(OppositeDir == "Opposite"),
                         color = stim_color, alpha = 0.9, size = 1.1), dpi = 300) +
    geom_abline(slope = 1, intercept = 0, linetype = "dashed", color = "gray30") +
    geom_hline(yintercept = 0, linetype = "solid", color = "black") +
    geom_vline(xintercept = 0, linetype = "solid", color = "black") +
    coord_fixed(xlim = c(-5, 5), ylim = c(-5, 5)) +
    labs(title = paste0("logFC H vs C - ", stim_name),
         x = expression(log[2]*"FC H"),
         y = expression(log[2]*"FC C")) +
    annotate("text", x = -4.5, y = 4.5, label = cor_label,
             hjust = 0, vjust = 1, size = 4) +
    annotate("text", x = 4.5, y = -4.5, 
             label = paste0("n = ", n_opposite),
             hjust = 1, vjust = 0, size = 4, color = stim_color) +
    theme_custom()
  
  plots[[st]] <- p
  print(p)
}

print(spearman_res)


combined_plot <- plots[["DOX"]] + plots[["NUTL"]] +
  plot_annotation(theme = theme_custom())

# Save with your custom save_plot function
# save_plot(combined_plot, 
#           "DOX_NUTL_logFC_correlation_EMP", 
#           width = 10, height = 5,
#           folder = output_folder)


```

#Species Specific logFC Correlation Scatterplots - all stimuli
```{r Species Specific logFC Cor Scatter all}
#define stimuli
stim_all <- c("TUN2", "THA2", "DOX2", "NUTL2",
             "LPS2", "TNFa2", "BPA2", "PFOA2",
             "TUN24", "THA24", "DOX24", "NUTL24",
             "LPS24", "TNFa24", "BPA24", "PFOA24")

spearman_res_all <- data.frame(
  Stimulus = character(),
  Rho = numeric(),
  pvalue = numeric(),
  stringsAsFactors = FALSE
)

plots_all <- list()

for (st in stim_all) {
  # Make object names
  nm_H <- paste0("V.", st, "_H")
  nm_C <- paste0("V.", st, "_C")
  
  if (!(nm_H %in% names(toptable_list)) | !(nm_C %in% names(toptable_list))) {
    message("Skipping ", st, " (missing H or C)")
    next
  }
  
  stim_name <- st
  stim_color <- ifelse(stim_name %in% names(stim_col), 
                       stim_col[stim_name], "black")
  
  df_h <- toptable_list[[nm_H]] %>% 
    mutate(Entrez_ID = as.character(Entrez_ID))
  df_c <- toptable_list[[nm_C]] %>% 
    mutate(Entrez_ID = as.character(Entrez_ID))
  
  # Merge by Entrez ID
  merged_df_all <- inner_join(df_h, df_c, by = "Entrez_ID",
                              suffix = c("_H", "_C")) %>% 
    dplyr::select(Entrez_ID, logFC_H = logFC_H, logFC_C = logFC_C)
  
  # Identify opposite-direction genes
  merged_df_all <- merged_df_all %>%
    mutate(OppositeDir = case_when(
      logFC_H > 0 & logFC_C < 0 ~ "Opposite",
      logFC_H < 0 & logFC_C > 0 ~ "Opposite",
      TRUE ~ "Same"
    ))
  
  n_opposite <- sum(merged_df_all$OppositeDir == "Opposite")
  
  # Spearman correlation
  cor_test <- cor.test(merged_df_all$logFC_H, merged_df_all$logFC_C, 
                       method = "spearman")
  rho <- round(cor_test$estimate, 2)
  pval <- ifelse(cor_test$p.value < 0.001, "<0.001",
                 round(cor_test$p.value, 3))
  cor_label <- paste0("rho = ", rho, "\n", "p = ", pval)
  
  spearman_res_all <- rbind(spearman_res_all,
                            data.frame(Stimulus = st,
                                       Rho = rho,
                                       pvalue = cor_test$p.value))
  
  #scatterplots
  p <- ggplot(merged_df_all, aes(x = logFC_H, y = logFC_C)) +
    rasterise(geom_point(data = merged_df_all %>% 
                           filter(OppositeDir == "Same"),
                         color = "black", alpha = 0.5, 
                         size = 0.8), 
              dpi = 300) +
    rasterise(geom_point(data = merged_df_all %>% 
                           filter(OppositeDir == "Opposite"),
                         color = stim_color, alpha = 0.9, 
                         size = 1.1), dpi = 300) +
    geom_abline(slope = 1, intercept = 0, 
                linetype = "dashed", color = "gray30") +
    geom_hline(yintercept = 0, linetype = "solid", color = "black") +
    geom_vline(xintercept = 0, linetype = "solid", color = "black") +
    coord_fixed(xlim = c(-5, 5), ylim = c(-5, 5)) +
    labs(title = paste0("logFC H vs C - ", st),
         x = expression(log[2]*"FC H"),
         y = expression(log[2]*"FC C")) +
    annotate("text", x = -4.5, y = 4.5, label = cor_label,
             hjust = 0, vjust = 1, size = 4) +
    annotate("text", x = 4.5, y = -4.5, 
             label = paste0("n = ", n_opposite),
             hjust = 1, vjust = 0, size = 4, color = stim_color) +
    theme_custom()
  
  plots_all[[st]] <- p
  print(p)
}

print(spearman_res_all)

#print single plots
for (st in stim_all) {
  p <- plots_all[[st]]
  print(p)
  filename_base <- paste0("Species_logFC_Cor_scatter_", st, "_EMP")
  save_plot(plot = p, filename = filename_base, folder = output_folder,
            width = 5, height = 5)
}

#save as 2x4 grid
# combined_plot_2x4 <- wrap_plots(
#   plots_all[["TUN"]],
#   plots_all[["THA"]],
#   plots_all[["DOX"]],
#   plots_all[["NUTL"]],
#   plots_all[["LPS"]],
#   plots_all[["TNFa"]],
#   plots_all[["BPA"]],
#   plots_all[["PFOA"]],
#   ncol = 4,
#   nrow = 2
# ) + plot_annotation(theme = theme_custom())

#save â€” each plot as 5x5 â†’ total 20x10 inches
# save_plot(
#   plot = combined_plot_2x4,
#   filename = "Species_logFC_Cor_scatter_allstimuli_2x4_EMP",
#   folder = output_folder,
#   width = 20,
#   height = 10
# )

#now save this as a 4x2 grid just in case
# combined_plot_4x2 <- wrap_plots(
#   plots_all[["TUN"]],
#   plots_all[["THA"]],
#   plots_all[["DOX"]],
#   plots_all[["NUTL"]],
#   plots_all[["LPS"]],
#   plots_all[["TNFa"]],
#   plots_all[["BPA"]],
#   plots_all[["PFOA"]],
#   ncol = 2,
#   nrow = 4
# ) + plot_annotation(theme = theme_custom())

#save â€” each plot 5x5 = total 10x20 inches
# save_plot(
#   plot = combined_plot_4x2,
#   filename = "Species_logFC_Cor_scatter_allstimuli_4x2_EMP",
#   folder = output_folder,
#   width = 10,
#   height = 20
# )


```
#Timepoint Comparisons
```{r Compare timepoints across species}
#instead of species comparisons, make timepoint comparisons

# Define all stimuli
stimuli <- c("TUN", "THA", "DOX", "NUTL", "LPS", "TNFa", "BPA", "PFOA")

# Initialize result table and plot list
spearman_res_time <- data.frame(
  Stimulus = character(),
  Species = character(),
  Rho = numeric(),
  pvalue = numeric(),
  stringsAsFactors = FALSE
)

plots_time <- list()

# Loop through each stimulus and species
for (st in stimuli) {
  for (sp in c("H", "C")) {
    
    nm_t2 <- paste0("V.", st, "2_", sp)
    nm_t24 <- paste0("V.", st, "24_", sp)
    
    # Check for missing data
    if (!(nm_t2 %in% names(toptable_list)) | !(nm_t24 %in% names(toptable_list))) {
      message("Skipping ", st, " - ", sp, " (missing 2h or 24h data)")
      next
    }
    
    # Color for each stimulus
    stim_color <- ifelse(st %in% names(stim_col), stim_col[st], "black")
    
    # Load data
    df_t2 <- toptable_list[[nm_t2]] %>% mutate(Entrez_ID = as.character(Entrez_ID))
    df_t24 <- toptable_list[[nm_t24]] %>% mutate(Entrez_ID = as.character(Entrez_ID))
    
    # Merge on Entrez ID
    merged_df <- inner_join(df_t2, df_t24, by = "Entrez_ID",
                            suffix = c("_2", "_24")) %>%
      dplyr::select(Entrez_ID, logFC_2 = logFC_2, logFC_24 = logFC_24)
    
    # Identify opposite direction genes
    merged_df <- merged_df %>%
      mutate(OppositeDir = case_when(
        logFC_2 > 0 & logFC_24 < 0 ~ "Opposite",
        logFC_2 < 0 & logFC_24 > 0 ~ "Opposite",
        TRUE ~ "Same"
      ))
    
    n_opposite <- sum(merged_df$OppositeDir == "Opposite")
    
    # Spearman correlation
    cor_test <- cor.test(merged_df$logFC_2, merged_df$logFC_24, method = "spearman")
    rho <- round(cor_test$estimate, 2)
    pval <- ifelse(cor_test$p.value < 0.001, "<0.001", round(cor_test$p.value, 3))
    cor_label <- paste0("rho = ", rho, "\n", "p = ", pval)
    
    # Store correlation results
    spearman_res_time <- rbind(
      spearman_res_time,
      data.frame(Stimulus = st, Species = sp,
                 Rho = rho, pvalue = cor_test$p.value)
    )
    
    # Scatterplot: log2FC 2h vs 24h
    p <- ggplot(merged_df, aes(x = logFC_2, y = logFC_24)) +
      rasterise(geom_point(data = merged_df %>% filter(OppositeDir == "Same"),
                           color = "black", alpha = 0.5, size = 0.8), dpi = 300) +
      rasterise(geom_point(data = merged_df %>% filter(OppositeDir == "Opposite"),
                           color = stim_color, alpha = 0.9, size = 1.1), dpi = 300) +
      geom_abline(slope = 1, intercept = 0, linetype = "dashed", color = "gray30") +
      geom_hline(yintercept = 0, linetype = "solid", color = "black") +
      geom_vline(xintercept = 0, linetype = "solid", color = "black") +
      coord_fixed(xlim = c(-5, 5), ylim = c(-5, 5)) +
      labs(title = paste0(sp, ": ", st, " 2h vs 24h"),
           x = expression(log[2]*"FC 2h"),
           y = expression(log[2]*"FC 24h")) +
      annotate("text", x = -4.5, y = 4.5, label = cor_label,
               hjust = 0, vjust = 1, size = 4) +
      annotate("text", x = 4.5, y = -4.5,
               label = paste0("n = ", n_opposite),
               hjust = 1, vjust = 0, size = 4, color = stim_color) +
      theme_custom()
    
    # Store and print
    plots_time[[paste0(st, "_", sp)]] <- p
    print(p)
  }
}

# Print summary table
print(spearman_res_time)

# Save plots
for (nm in names(plots_time)) {
  p <- plots_time[[nm]]
  filename_base <- paste0("Timepoint_logFC_Cor_scatter_", nm, "_EMP")
  save_plot(plot = p, filename = filename_base, folder = output_folder,
            width = 5, height = 5)
}


```


#Pull out Species Specific Genes
```{r Species Specific Genes List}
#I want to pull out genes that are specific to each species to plot examples later
#I can use my merged_df from above with all stimuli to make a dataframe for classification of these genes based on logFC

#Human Specific = logFC H > 0, logFC C < 0
#Chimp Specific = logFC H < 0, logFC C > 0
#Shared = logFC H </> 0, logFC C </> 0


# merged_df_all <- merged_df %>% 
#   mutate(
#     Category = case_when(
#       logFC_H > 0 & logFC_C < 0 ~ "Human-specific",
#       logFC_H < 0 & logFC_C > 0 ~ "Chimp-specific",
#       sign(logFC_H) == sign(logFC_C) ~ "Shared"
#     )
#   ) %>% 
#   dplyr::select(Entrez_ID, logFC_H, logFC_C, Category)

# saveRDS(merged_df_all, "data/de/species_specific_classification_df.RDS")

#read in your new df 
merged_df_all <- readRDS("data/de/species_specific_classification_df.RDS")

#make one that is classified by stimulus as well
# all_gene_classified <- do.call(rbind, lapply(stimuli, function(st) {
#   nm_H <- paste0("V.", st, "24_H")
#   nm_C <- paste0("V.", st, "24_C")
# 
#   if (!(nm_H %in% names(toptable_list_24)) | !(nm_C %in% names(toptable_list_24))) {
#     return(NULL)
#   }
#   
#   df_h <- toptable_list_24[[nm_H]] %>% 
#     mutate(
#       Entrez_ID = as.character(Entrez_ID),
#       SYMBOL = as.character(SYMBOL),
#       adj.P.Val_H = adj.P.Val
#     )
# 
#   df_c <- toptable_list_24[[nm_C]] %>%
#     mutate(Entrez_ID = as.character(Entrez_ID),
#            SYMBOL = as.character(SYMBOL),
#            adj.P.Val_C = adj.P.Val
#     )
# 
#   df_species_spec <- data.frame(
#     Entrez_ID = df_h$Entrez_ID,
#     SYMBOL = df_h$SYMBOL,
#     logFC_H = as.numeric(df_h$logFC),
#     logFC_C = as.numeric(df_c$logFC),
#     adj.P.Val_H = as.numeric(df_h$adj.P.Val_H),
#     adj.P.Val_C = as.numeric(df_c$adj.P.Val_C)
#   ) %>%
#     mutate(
#       Category = case_when(
#         logFC_H > 0 & logFC_C < 0 ~ "Human-specific",
#         logFC_H < 0 & logFC_C > 0 ~ "Chimp-specific",
#         sign(logFC_H) == sign(logFC_C) ~ "Shared"
#       ),
#       Stimulus = st,
#       Time = "24"
#     )
# 
#   return(df_species_spec)
# }))

#now I want to add a column that denotes whether or not a gene is DE
# all_gene_classified <- all_gene_classified %>%
#   mutate(
#     DE_H = ifelse(adj.P.Val_H < 0.05, TRUE, FALSE),
#     DE_C = ifelse(adj.P.Val_C < 0.05, TRUE, FALSE)
#   )

# saveRDS(all_gene_classified, "data/de/specspec/all_classified_genes_df.RDS")

#now pull the data to get the genes for each category
# h_spec_genes <- all_gene_classified %>% filter(Category == "Human-specific")
# saveRDS(h_spec_genes, "data/de/specspec/human_specific_df.RDS")
# h_spec_genes_list <- h_spec_genes$Entrez_ID
# saveRDS(h_spec_genes_list, "data/de/specspec/human_specific_entrezid_list.RDS")
#
# c_spec_genes <- all_gene_classified %>% filter(Category == "Chimp-specific")
# saveRDS(c_spec_genes, "data/de/specspec/chimp_specific_df.RDS")
# c_spec_genes_list <- c_spec_genes$Entrez_ID
# saveRDS(c_spec_genes_list, "data/de/specspec/chimp_specific_entrezid_list.RDS")

# hc_shared_genes <- all_gene_classified %>% filter(Category == "Shared")
# saveRDS(hc_shared_genes, "data/de/specspec/shared_genes_df_hc.RDS")
# hc_shared_genes_list <- hc_shared_genes$Entrez_ID
# saveRDS(hc_shared_genes_list, "data/de/specspec/shared_hc_genes_entrezid_list.RDS")

#keep this for posterity, but I have saved each of these as RDS objects
all_gene_classified <- readRDS("data/de/specspec/all_classified_genes_df.RDS")

#make a short table
all_gene_classified_table <- table(all_gene_classified$Stimulus, all_gene_classified$Category)

print(all_gene_classified_table)

#create a list of stimulus specific and species specific dataframes
# species_gene_list <- list()
# 
# for (st in stimuli) {
#   nm_H <- paste0("V.", st, "24_H")
#   nm_C <- paste0("V.", st, "24_C")
#   
#   df_h <- toptable_list_24[[nm_H]] %>% 
#     dplyr::select(SYMBOL, Entrez_ID, adj.P.Val, logFC)
#   df_c <- toptable_list_24[[nm_C]] %>% 
#     dplyr::select(SYMBOL, Entrez_ID, adj.P.Val, logFC)
#     
#     df_species_spec <- data.frame(
#     Entrez_ID = df_h$Entrez_ID,
#     SYMBOL = df_h$SYMBOL,
#     logFC_H = as.numeric(df_h$logFC),
#     logFC_C = as.numeric(df_c$logFC)
#   ) %>%
#     mutate(
#       Category = case_when(
#         logFC_H > 0 & logFC_C < 0 ~ "Human-specific",
#         logFC_H < 0 & logFC_C > 0 ~ "Chimp-specific",
#         sign(logFC_H) == sign(logFC_C) ~ "Shared"
#       ),
#       Stimulus = st,
#     )
#   
#   # save the dataframe to the list
#   species_gene_list[[st]] <- df_species_spec
# }

# saveRDS(species_gene_list, "data/de/specspec/species_categorized_genes_bystim_listofdf.RDS")

# species_gene_list <- readRDS("data/de/specspec/species_categorized_genes_bystim_listofdf.RDS")
# 
# dic_symbols <- dic_genes$SYMBOL

# #check if genes are differentially expressed
# de_specspec_dic <- all_gene_classified %>%
#   filter(SYMBOL %in% dic_symbols,      # must be in your DDR gene list
#          (Category == "Human-specific" & adj.P.Val_H < 0.05) |
#          (Category == "Chimp-specific" & adj.P.Val_C < 0.05) |
#          (Category == "Shared" & (adj.P.Val_H < 0.05 | adj.P.Val_C < 0.05))) %>%
#   arrange(Category)

# de_specspec_all <- all_gene_classified %>%
#   filter((Category == "Human-specific" & adj.P.Val_H < 0.05) |
#          (Category == "Chimp-specific" & adj.P.Val_C < 0.05) |
#          (Category == "Shared" & (adj.P.Val_H < 0.05 | adj.P.Val_C < 0.05))) %>%
#   arrange(Category)

# saveRDS(de_specspec_all, "data/de/specspec/degs_speciesspecific_all.RDS")

#now I have filtered for DE genes within these two sets across categories

```

```{r Prep for log2cpm boxplots}
#plot a human specific gene, chimp specific gene, and a shared gene
#look first at those that are in your dic_ids list to see if any are present across stimuli and then plot

#read in my filtered cpm matrix
# hc_cpm_mat_24 <- readRDS("data/counts/hc_filtered_cpm_matrix_24hr.RDS")
colnames(hc_cpm_mat_24) <- meta_bp_24$Samples_24
# hc_cpm_mat_24 <- as.matrix(hc_cpm_mat_24)
#add in symbol names
# hc_cpm_24 <- hc_cpm_mat_24 %>% 
#   as.data.frame() %>% 
#   mutate(
#     Entrez_ID = rownames(.),
#     SYMBOL = mapIds(
#       org.Hs.eg.db,
#       keys = Entrez_ID,
#       column = "SYMBOL",
#       keytype = "ENTREZID",
#       multiVals = "first"
#     )
#   )
#change the column names to match my metadata

#filter all_gene_classified to only have DOX and NUTL
gene_classified_ddr <- all_gene_classified %>% 
  dplyr::filter(Stimulus %in% c("DOX", "NUTL")) %>% 
  arrange(Category)

dic_gene_classified <- gene_classified_ddr %>% 
  dplyr::filter(SYMBOL %in% dic_symbols) %>% 
  arrange(Category)

category_counts_ddr <- dic_gene_classified %>% 
  group_by(Category) %>% 
  summarise(n_genes = n_distinct(SYMBOL))

#return all of the genes that are species specific
human_DOX <- gene_classified_ddr %>% 
  dplyr::filter(Stimulus == "DOX") %>% 
  filter(Category == "Human-specific") %>% 
  pull(SYMBOL)

chimp_DOX <- gene_classified_ddr %>% 
  dplyr::filter(Stimulus == "DOX") %>% 
  filter(Category == "Chimp-specific") %>% 
  pull(SYMBOL)

shared_DOX <- gene_classified_ddr %>% 
  dplyr::filter(Stimulus == "DOX") %>% 
  filter(Category == "Shared") %>% 
  pull(SYMBOL)

#now the nutl groups
human_NUTL <- gene_classified_ddr %>% 
  dplyr::filter(Stimulus == "NUTL") %>% 
  filter(Category == "Human-specific") %>% 
  pull(SYMBOL)

chimp_NUTL <- gene_classified_ddr %>% 
  dplyr::filter(Stimulus == "NUTL") %>% 
  filter(Category == "Chimp-specific") %>% 
  pull(SYMBOL)

shared_NUTL <- gene_classified_ddr %>% 
  dplyr::filter(Stimulus == "NUTL") %>% 
  filter(Category == "Shared") %>% 
  pull(SYMBOL)

order_bps <- c("DOX_H", "NUTL_H", "DMSO_H",
               "DOX_C", "NUTL_C", "DMSO_C")

# combine all groups into a list
gene_groups <- list(
  human_DOX = human_DOX,
  human_NUTL = human_NUTL,
  chimp_DOX = chimp_DOX,
  chimp_NUTL = chimp_NUTL,
  shared_DOX = shared_DOX,
  shared_NUTL = shared_NUTL
)

#minimize my metadata sheet 
# meta_bp_24 <- meta_24 %>% 
#   mutate(
#     Samples_24 = paste(Stimulus, Ind_Num, Species, sep = "_")
#     ) %>% 
#   dplyr::select("Samples_24", "Drug", "Response", "Species", "Ind", "Ind_Num") %>% 
#   dplyr::rename(Stimulus = Drug)

# saveRDS(meta_bp_24, "data/counts/metadata_24hr_boxplots_shortened.RDS")

meta_bp_24 <- readRDS("data/counts/metadata_24hr_boxplots_shortened.RDS")

#read in my filtered cpm matrix
# hc_cpm_mat_24 <- readRDS("data/counts/hc_filtered_cpm_matrix_24hr.RDS")
# colnames(hc_cpm_24) <- meta_bp_24$Samples_24
 
# write.csv(hc_cpm_24, "data/counts/hc_cpm_filt_24hr_entrezsymbol.csv")

#all_gene_classified subset
all_gene_classified_set <- all_gene_classified %>% 
  dplyr::select("Entrez_ID", "SYMBOL", "Category", "Stimulus", 
                "DE_H", "DE_C")

#now read in the above as my boxplot df with Entrez_ID and SYMBOL
boxplot_df <- read.csv("data/counts/hc_cpm_filt_24hr_entrezsymbol.csv")

#make sure Entrez_ID is a character
boxplot_df$Entrez_ID <- as.character(boxplot_df$Entrez_ID)

#make my boxplot_df into long format
#add in gene classifications for easy comparisons
boxplot_long <- boxplot_df %>% 
  pivot_longer(
    cols = -c(Entrez_ID, SYMBOL),
    names_to = "Samples_24",
    values_to = "log2cpm"
  ) %>% 
  mutate(
    Stimulus = str_extract(Samples_24, "^[^_]+"),
    Ind_Num = str_extract(Samples_24, "(?<=_)[0-9]+"),
    Species = str_extract(Samples_24, "[HC]$")
  ) %>% 
  left_join(
    all_gene_classified_set %>% 
      dplyr::select(Entrez_ID, SYMBOL, Stimulus, Category, DE_H, DE_C),
    by = c("Entrez_ID", "SYMBOL", "Stimulus")
  ) %>% 
  mutate(
    DEG = case_when(
      Species == "H" ~ DE_H,
      Species == "C" ~ DE_C
    )
  ) %>% 
  dplyr::select(Entrez_ID, SYMBOL, log2cpm, Samples_24, Stimulus, Species, Ind_Num, Category, DEG)

#now select only the DDR stimuli and vehicle
boxplot_long_ddr <- boxplot_long %>% 
  dplyr::filter(Stimulus %in% c("DOX", "NUTL", "DMSO"))

```

##plot log2cpm example genes
```{r log2cpm example genes species specific}
#now make a function to run through the data above and make boxplots

# set.seed(9196)  # for reproducibility
selected_genes <- boxplot_long_ddr %>%
  filter(Stimulus %in% c("DOX", "NUTL"), DEG == TRUE) %>%
  group_by(Category, Species, Stimulus) %>%
  summarise(
    Gene_pick = list(sample(unique(SYMBOL), 
                            size = min(10, length(unique(SYMBOL))),
                            replace = FALSE))
  ) %>%
  ungroup() %>%
  pull(Gene_pick) %>%
  unlist()

#filter for randomly selected example genes (which are DE) 
plot_data <- boxplot_long_ddr %>%
  filter(SYMBOL %in% selected_genes, 
         Stimulus %in% c("DOX", "NUTL", "DMSO"))

#map individual and stimulus colors 
plot_data <- plot_data %>%
  mutate(
    Indv_name = ind_vec[as.character(Ind_Num)], 
    Indv_col = ind_col[Indv_name],
    Stim_col = stim_col[Stimulus],
    Group = paste0(Stimulus, "_", Species)   
  )

#now make sure everything is factored to be in the correct order

ind_levels <- paste0("Ind", 1:14)
group_levels <- c("DOX_H", "NUTL_H", "DMSO_H",
                  "DOX_C", "NUTL_C", "DMSO_C")
stim_levels <- c("DOX", "NUTL", "DMSO")

plot_data <- plot_data %>%
  mutate(
    Indv_name = factor(Indv_name, levels = ind_levels),
    Group = factor(Group, levels = group_levels),
    Stimulus = factor(Stimulus, levels = stim_levels)
  )

#plot gene data for example genes - 3 per condition

for(gene in unique(plot_data$SYMBOL)) {
  gene_data <- plot_data %>% filter(SYMBOL == gene)
  gene_cat <- unique(gene_data$Category)
  
  p <- ggplot(gene_data, aes(x = Group, y = log2cpm, fill = Stimulus)) +
    geom_boxplot() +
    geom_point(aes(color = Indv_name), 
               size = 2, alpha = 0.7, 
               position = position_identity()) +
    scale_fill_manual(values = stim_col) +
    scale_color_manual(values = ind_col) +
    ggtitle(paste("log2cpm Expression ", gene, " - ", gene_cat)) +
    labs(x = "Condition", y = expression("log"[2]*"cpm")) +
    theme_custom()
  
  print(p)
}
```


```{r}
selected_genes <- boxplot_long_ddr %>%
  filter(Stimulus %in% c("DOX", "NUTL")) %>%
  group_by(Category, Species) %>%
  summarise(
    Gene_pick = list(
      sample(unique(SYMBOL[DEG == TRUE]), 
             size = min(2, sum(DEG == TRUE, na.rm = TRUE)),
             replace = FALSE)
    )
  ) %>%
  ungroup() %>%
  pull(Gene_pick) %>%
  unlist() %>%
  na.omit()


plot_data_selected <- boxplot_long_ddr %>%
  filter(SYMBOL %in% selected_genes, Stimulus %in% c("DOX", "NUTL", "DMSO")) %>%
  mutate(
    Indv_name = ind_vec[as.character(Ind_Num)],
    Stim_col = stim_col[Stimulus],
    Group = paste0(Stimulus, "_", Species)
  )

ind_levels <- paste0("Ind", 1:14)
group_levels <- c("DOX_H", "NUTL_H", "DMSO_H", 
                  "DOX_C", "NUTL_C", "DMSO_C")
stim_levels <- c("DOX", "NUTL", "DMSO")

plot_data_selected <- plot_data_selected %>%
  mutate(
    Indv_name = factor(Indv_name, levels = ind_levels),
    Group = factor(Group, levels = group_levels),
    Stimulus = factor(Stimulus, levels = stim_levels)
  )

for(gene in unique(plot_data_selected$SYMBOL)) {
  gene_data <- plot_data_selected %>% filter(SYMBOL == gene)
  gene_category <- unique(gene_data$Category)
  
  p <- ggplot(gene_data, aes(x = Group, y = log2cpm, fill = Stimulus)) +
    geom_boxplot(outlier.shape = NA) +
    geom_point(aes(color = Indv_name), size = 2, 
               alpha = 0.7,
               position = position_identity()) +
    scale_fill_manual(values = stim_col) +
    scale_color_manual(values = ind_col) +
    ggtitle(paste0("Log2CPM Expression of ", gene,
                   " (", gene_category, ")")) +
    labs(x = "Condition", y = expression("log"[2]*"cpm")) +
    theme_custom()
  
  print(p)
}

# --- Step 5: Repeat for genes in dic_symbols ---
plot_data_dic <- boxplot_long_ddr %>%
  filter(SYMBOL %in% dic_symbols, Stimulus %in% c("DOX", 
                                                  "NUTL", 
                                                  "DMSO")
         ) %>%
  mutate(
    Indv_name = ind_vec[as.character(Ind_Num)],
    Stim_col = stim_col[Stimulus],
    Group = paste0(Stimulus, "_", Species)
  ) %>%
  mutate(
    Indv_name = factor(Indv_name, levels = ind_levels),
    Group = factor(Group, levels = group_levels),
    Stimulus = factor(Stimulus, levels = stim_levels)
  )

# Plot for dic_symbols genes
for(gene in unique(plot_data_dic$SYMBOL)) {
  gene_data <- plot_data_dic %>% filter(SYMBOL == gene)
  gene_category <- unique(gene_data$Category)
  
  p <- ggplot(gene_data, aes(x = Group, y = log2cpm, fill = Stimulus)) +
    geom_boxplot(outlier.shape = NA) +
    geom_point(aes(color = Indv_name), size = 2, alpha = 0.7,
               position = position_identity()) +
    scale_fill_manual(values = stim_col) +
    scale_color_manual(values = ind_col) +
    ggtitle(paste0("Log2CPM Expression of ", gene, 
                   " (", gene_category, ")")) +
    labs(x = "Condition", y = expression("log"[2]*"cpm")) +
    theme_custom()
  
  print(p)
}


```


```{r}
# (Category == "Human-specific" & Species == "H") |


selected_genes <- boxplot_long_ddr %>%
  filter(Stimulus == "DOX", DEG == TRUE) %>%
  filter(Category == "Chimp-specific" & Species == "C") %>%
  group_by(Category, Species) %>%
  summarise(
    Gene_pick = list(sample(unique(SYMBOL), 
                            size = min(10, length(unique(SYMBOL))), 
                            replace = FALSE))
  ) %>%
  ungroup() %>%
  pull(Gene_pick) %>%
  unlist()

# --- Step 2: Prepare plotting dataframe including all three conditions ---
plot_data_selected <- boxplot_long_ddr %>%
  filter(SYMBOL %in% selected_genes, Stimulus %in% c("DOX", "NUTL", "DMSO")) %>%
  mutate(
    Indv_name = ind_vec[as.character(Ind_Num)],
    Stim_col = stim_col[Stimulus],
    Group = paste0(Stimulus, "_", Species),
    Group = factor(Group, levels = c("DOX_H","NUTL_H","DMSO_H",
                                     "DOX_C","NUTL_C","DMSO_C")),
    Stimulus = factor(Stimulus, levels = c("DOX","NUTL","DMSO"))
  )

# --- Step 3: Plotting loop ---
for(gene in unique(plot_data_selected$SYMBOL)) {
  gene_data <- plot_data_selected %>% filter(SYMBOL == gene)
  gene_category <- unique(gene_data$Category)
  
  p <- ggplot(gene_data, aes(x = Group, y = log2cpm, fill = Stimulus)) +
    geom_boxplot(outlier.shape = NA) +
    geom_point(aes(color = Indv_name),
               size = 2, alpha = 0.7,
               position = position_identity()) +
    scale_fill_manual(values = stim_col) +
    scale_color_manual(values = ind_col) +
    ggtitle(paste0("Log2CPM Expression of ", gene, 
                   " (", gene_category, ")")) +
    labs(x = "Condition", y = "log2cpm") +
    theme_custom()
  
  print(p)
}
```


```{r log2cpm example genes species specific plots}
#change my workflow to DEGs in both species which are species specific


get_species_specific_example <- function(df, stimulus, species, category) {
  df_sub <- df %>% filter(Stimulus %in% c(stimulus, "DMSO"))
  
  candidate_genes <- df_sub %>%
    group_by(SYMBOL, Category) %>%
    summarise(
      de_target = any(DEG[Species == species & Stimulus == stimulus],
                      na.rm = TRUE),
      de_other = any(DEG[!(Species == species & Stimulus == stimulus)],
                     na.rm = TRUE),
      .groups = "drop"
    ) %>%
    filter(Category == category, de_target & !de_other)
  
  # Randomly pick 1 gene
  sample(candidate_genes$SYMBOL, 2)
}

example_gene_dox_chimp <- get_species_specific_example(boxplot_long_ddr, "DOX", "C", "Chimp-specific")
example_gene_dox_human <- get_species_specific_example(boxplot_long_ddr, "DOX", "H", "Human-specific")

example_gene_nutl_chimp <- get_species_specific_example(boxplot_long_ddr, "NUTL", "C", "Chimp-specific")
example_gene_nutl_human <- get_species_specific_example(boxplot_long_ddr, "NUTL", "H", "Human-specific")

prepare_plot_data <- function(df, genes) {
  df %>%
    filter(SYMBOL %in% genes, Stimulus %in% c("DOX","NUTL","DMSO")) %>%
    mutate(
    Indv_name = ind_vec[as.character(Ind_Num)],
    Stim_col = stim_col[Stimulus],
    Group = paste0(Stimulus, "_", Species)
    ) %>%
  mutate(
    Indv_name = factor(Indv_name, levels = ind_levels),
    Group = factor(Group, levels = group_levels),
    Stimulus = factor(Stimulus, levels = stim_levels)
    )
}

plot_data <- prepare_plot_data(boxplot_long_ddr,
                               c(example_gene_dox_chimp,
                                 example_gene_dox_human,   
                                 example_gene_nutl_chimp,
                                 example_gene_nutl_human))


plot_gene_example <- function(plot_data, gene) {
  gene_data <- plot_data %>% filter(SYMBOL == gene)
  gene_category <- unique(gene_data$Category)
  
  ggplot(gene_data, aes(x = Group, y = log2cpm, fill = Stimulus)) +
    geom_boxplot(outlier.shape = NA) +
    geom_point(aes(color = Indv_name), size = 2, 
               alpha = 0.7, position = position_identity()) +
    scale_fill_manual(values = stim_col) +
    scale_color_manual(values = ind_col) +
    theme_custom() +
    ggtitle(paste0(gene, " (", gene_category, ")"))
}

for(gene in unique(plot_data$SYMBOL)) {
  print(plot_gene_example(plot_data, gene))
}

```



```{r try again to get species specific genes}
select_species_specific_genes <- function(df, stimulus, n_genes = 3) {
  df_sub <- df %>% filter(Stimulus == stimulus)
  
  # Human-specific genes that are DE in H
  human_genes <- df_sub %>%
    filter(Category == "Human-specific", DE_H == TRUE) %>%
    distinct(SYMBOL) %>%
    slice_sample(n = n_genes) %>%
    pull(SYMBOL)
  
  # Chimp-specific genes that are DE in C
  chimp_genes <- df_sub %>%
    filter(Category == "Chimp-specific", DE_C == TRUE) %>%
    distinct(SYMBOL) %>%
    slice_sample(n = n_genes) %>%
    pull(SYMBOL)
  
  c(human_genes, chimp_genes)
}


selected_genes_dox <- select_species_specific_genes(de_specspec_all, "DOX", 3)
selected_genes_nutl <- select_species_specific_genes(de_specspec_all, "NUTL", 3)
selected_genes <- c(selected_genes_dox, selected_genes_nutl)


plot_data <- boxplot_long_ddr %>%
  filter(SYMBOL %in% selected_genes, Stimulus %in% c("DOX","NUTL","DMSO")) %>%
  mutate(
    Indv_name = paste0("Ind", Ind_Num),
    Indv_name = factor(Indv_name, levels = paste0("Ind", 1:14)),
    Group = paste0(Stimulus, "_", Species),
    Group = factor(Group, levels = c("DOX_H","NUTL_H","DMSO_H","DOX_C","NUTL_C","DMSO_C")),
    Stimulus = factor(Stimulus, levels = c("DOX","NUTL","DMSO"))
  )

plot_species_specific_gene <- function(df, gene) {
  gene_data <- df %>% filter(SYMBOL == gene)
  gene_category <- unique(gene_data$Category)
  
  ggplot(gene_data, aes(x = Group, y = log2cpm, fill = Stimulus)) +
    geom_boxplot(outlier.shape = NA) +
    geom_point(aes(color = Indv_name), size = 2, alpha = 0.8, position = position_identity()) +
    scale_fill_manual(values = stim_col) +
    scale_color_manual(values = ind_col) +
    theme_custom() +
    ggtitle(paste0(gene, " (", gene_category, ")"))
}

# --- Step 5: Loop through genes and plot ---
for(gene in selected_genes) {
  print(plot_species_specific_gene(plot_data, gene))
}

```


```{r DIC genes log2cpm examples}
#try and plot the ones that are species specific in DIC

dic_plot_genes <- de_specspec_all %>%
  filter(SYMBOL %in% dic_symbols, 
         Category %in% c("Human-specific","Chimp-specific")) %>%
  distinct(SYMBOL, Category)  # keep track of category too

# --- Step 2: Prepare plotting dataframe ---
plot_data_dic <- boxplot_long_ddr %>%
  filter(SYMBOL %in% dic_plot_genes$SYMBOL, Stimulus %in% c("DOX","NUTL","DMSO")) %>%
  left_join(dic_plot_genes %>% select(SYMBOL, Category), by = "SYMBOL") %>%  # add category
  mutate(
    Indv_name = paste0("Ind", Ind_Num),
    Indv_name = factor(Indv_name, levels = paste0("Ind", 1:14)),
    Group = paste0(Stimulus, "_", Species),
    Group = factor(Group, levels = c("DOX_H","NUTL_H","DMSO_H","DOX_C","NUTL_C","DMSO_C")),
    Stimulus = factor(Stimulus, levels = c("DOX","NUTL","DMSO"))
  )

# --- Step 3: Plotting function ---
plot_species_specific_gene <- function(df, gene) {
  gene_data <- df %>% filter(SYMBOL == gene)
  gene_category <- unique(gene_data$Category)
  
  ggplot(gene_data, aes(x = Group, y = log2cpm, fill = Stimulus)) +
    geom_boxplot(outlier.shape = NA) +
    geom_point(aes(color = Indv_name), size = 2, alpha = 0.8, position = position_identity()) +
    scale_fill_manual(values = stim_col) +
    scale_color_manual(values = ind_col) +
    theme_custom() +
    ggtitle(paste0(gene, " (", gene_category, ")"))
}

# --- Step 4: Loop through all DIC species-specific genes ---
for(gene in dic_plot_genes$SYMBOL) {
  print(plot_species_specific_gene(plot_data_dic, gene))
}
```

```{r}

dic_de_genes <- de_specspec_all %>%
  filter(SYMBOL %in% dic_symbols, DE_H == TRUE, DE_C == TRUE) %>%
  select(Entrez_ID, Category) %>%  # only bring Category
  distinct()

# --- Step 2: Remove Category from boxplot_long_ddr to prevent column collision ---
boxplot_long_ddr <- boxplot_long_ddr %>% select(-Category)

# --- Step 3: Join Category from dic_de_genes ---
plot_data_dic <- boxplot_long_ddr %>%
  filter(SYMBOL %in% dic_symbols, Stimulus %in% c("DOX","NUTL","DMSO")) %>%
  left_join(dic_de_genes, by = "Entrez_ID") %>%
  mutate(
    Indv_name = paste0("Ind", Ind_Num),
    Indv_name = factor(Indv_name, levels = paste0("Ind", 1:14)),
    Group = paste0(Stimulus, "_", Species),
    Group = factor(Group, levels = c("DOX_H","NUTL_H","DMSO_H","DOX_C","NUTL_C","DMSO_C")),
    Stimulus = factor(Stimulus, levels = c("DOX","NUTL","DMSO"))
  )

# --- Step 4: Plotting function ---
plot_de_gene <- function(df, gene) {
  gene_data <- df %>% filter(SYMBOL == gene)
  gene_category <- unique(gene_data$Category)
  
  ggplot(gene_data, aes(x = Group, y = log2cpm, fill = Stimulus)) +
    geom_boxplot(outlier.shape = NA) +
    geom_point(aes(color = Indv_name), size = 2, alpha = 0.8, position = position_identity()) +
    scale_fill_manual(values = stim_col) +
    scale_color_manual(values = ind_col) +
    theme_custom() +
    ggtitle(paste0(gene, " (", gene_category, ")"))
}

# --- Step 5: Loop through all DIC DE genes ---
for(gene in plot_data_dic$SYMBOL %>% unique()) {
  print(plot_de_gene(plot_data_dic, gene))
}
```
#simplify 
```{r Simplify log2cpm example genes}
#I want to just take the colored points from the scatterplots and categorize those

stim_ddr <- c("DOX", "NUTL", "DMSO")

# --- Step 1: Extract human-specific and chimp-specific genes from scatterplots ---
scatter_genes <- purrr::map_dfr(stim_ddr, function(st) {
  nm_H <- paste0("V.", st, "24_H")
  nm_C <- paste0("V.", st, "24_C")
  
  if (!(nm_H %in% names(toptable_list_24)) | !(nm_C %in% names(toptable_list_24))) {
    return(NULL)
  }
  
  df_h <- toptable_list_24[[nm_H]] %>% mutate(Entrez_ID = as.character(Entrez_ID))
  df_c <- toptable_list_24[[nm_C]] %>% mutate(Entrez_ID = as.character(Entrez_ID))
  
  merged_df <- data.frame(
    Entrez_ID = df_h$Entrez_ID,
    SYMBOL = if("SYMBOL" %in% colnames(df_h)) df_h$SYMBOL else NA_character_,
    logFC_H = as.numeric(df_h$logFC),
    logFC_C = as.numeric(df_c$logFC)
  )
  
  merged_df <- merged_df %>%
    mutate(Category = case_when(
      logFC_H > 0 & logFC_C < 0 ~ "Human-specific",
      logFC_H < 0 & logFC_C > 0 ~ "Chimp-specific",
      sign(logFC_H) == sign(logFC_C) ~ "Shared",
      TRUE ~ NA_character_
    )) %>%
    filter(!is.na(Category)) %>%
    mutate(Stimulus = st)
  
  return(merged_df)
})

# --- Step 2: Subset boxplot_df to only these genes ---
boxplot_subset <- boxplot_df %>%
  filter(Entrez_ID %in% scatter_genes$Entrez_ID)

# --- Step 3: Join in Category ---
boxplot_subset <- boxplot_subset %>%
  left_join(
    scatter_genes %>% dplyr::select(Entrez_ID, Category),
    by = "Entrez_ID"
  )

# --- Step 4: Pivot longer for plotting ---
bp_long_ddr <- boxplot_subset %>%
  pivot_longer(
    cols = -c(Entrez_ID, SYMBOL, Category),
    names_to = "Samples_24",
    values_to = "log2cpm"
  ) %>%
  mutate(
    Stimulus = case_when(
      grepl("DOX", Samples_24) ~ "DOX",
      grepl("NUTL", Samples_24) ~ "NUTL",
      grepl("DMSO", Samples_24) ~ "DMSO"
    ),
    Species = case_when(
      grepl("_H$", Samples_24) ~ "H",
      grepl("_C$", Samples_24) ~ "C"
    ),
    Group = paste0(Stimulus, "_", Species)
  )

bp_long_ddr <- bp_long_ddr %>%
  filter(grepl("DOX|NUTL|DMSO", Samples_24)) %>%
  mutate(
    # Extract species
    Species = case_when(
      grepl("_H$", Samples_24) ~ "H",
      grepl("_C$", Samples_24) ~ "C"
    ),
    # Extract stimulus
    Stimulus = case_when(
      grepl("DOX", Samples_24) ~ "DOX",
      grepl("NUTL", Samples_24) ~ "NUTL",
      grepl("DMSO", Samples_24) ~ "DMSO"
    ),
    # Extract individual number
    Ind_Num = as.numeric(gsub(".*_(\\d+)_.*", "\\1", Samples_24)),
    Indv_name = paste0("Ind", Ind_Num),
    Group = paste0(Stimulus, "_", Species)
  ) %>%
  filter(!is.na(Ind_Num))

# --- Step 5: Factor levels for plotting ---
ind_levels <- paste0("Ind", 1:14) 
group_levels <- c("DOX_H", "NUTL_H", "DMSO_H",
                  "DOX_C", "NUTL_C", "DMSO_C")
stim_levels <- c("DOX", "NUTL", "DMSO")

bp_long_ddr <- bp_long_ddr %>%
  mutate(
    Ind_Num = case_when(
      grepl("_1_", Samples_24) ~ 1,
      grepl("_2_", Samples_24) ~ 2,
      grepl("_3_", Samples_24) ~ 3,
      grepl("_4_", Samples_24) ~ 4,
      grepl("_5_", Samples_24) ~ 5,
      grepl("_6_", Samples_24) ~ 6,
      grepl("_7_", Samples_24) ~ 7,
      grepl("_8_", Samples_24) ~ 8,
      grepl("_9_", Samples_24) ~ 9,
      grepl("_10_", Samples_24) ~ 10,
      grepl("_11_", Samples_24) ~ 11,
      grepl("_12_", Samples_24) ~ 12,
      grepl("_13_", Samples_24) ~ 13,
      grepl("_14_", Samples_24) ~ 14,
      TRUE ~ NA_real_
    ),
    Indv_name = paste0("Ind", Ind_Num)
  )

bp_long_ddr <- bp_long_ddr %>%
  mutate(
    Indv_name = factor(Indv_name, levels = paste0("Ind", 1:14)),
    Group = factor(Group, levels = c("DOX_H", "NUTL_H", "DMSO_H",
                                     "DOX_C", "NUTL_C", "DMSO_C")),
    Stimulus = factor(Stimulus, levels = c("DOX", "NUTL", "DMSO"))
  )


# --- Step 6: Randomly select 3 genes per category ---
set.seed(9196)  # For reproducibility
selected_genes <- bp_long_ddr %>%
  group_by(Category) %>%
  reframe(GENE_PICK = sample(unique(SYMBOL), 10)) %>%
  pull(GENE_PICK)

plot_data <- bp_long_ddr %>%
  filter(SYMBOL %in% selected_genes)

#plot
for(gene in unique(plot_data$SYMBOL)) {
  gene_data <- plot_data %>% filter(SYMBOL == gene)
  gene_cat <- unique(gene_data$Category)
  
  p <- ggplot(gene_data, aes(x = Group, y = log2cpm, fill = Stimulus)) +
    geom_boxplot() +
    geom_point(aes(color = Indv_name), 
               size = 2, alpha = 0.7, 
               position = position_identity()) +
    scale_fill_manual(values = stim_col) +
    scale_color_manual(values = ind_col) +
    ggtitle(paste("log2cpm Expression ", gene, " - ", gene_cat)) +
    labs(x = "Condition", y = expression("log"[2]*"cpm")) +
    theme_custom()
  
  print(p)
}


```

```{r}

library(dplyr)
library(tidyr)
library(ggplot2)

# --- Factor levels for plotting ---
ind_levels <- paste0("Ind", 1:14)
group_levels <- c("DOX_H", "NUTL_H", "DMSO_H",
                  "DOX_C", "NUTL_C", "DMSO_C")
stim_levels <- c("DOX", "NUTL", "DMSO")

# --- Filter bp_long_ddr to only relevant stimuli ---
bp_long_ddr <- bp_long_ddr %>%
  filter(grepl("DOX|NUTL|DMSO", Samples_24)) %>%
  mutate(
    Stimulus = case_when(
      grepl("DOX", Samples_24) ~ "DOX",
      grepl("NUTL", Samples_24) ~ "NUTL",
      grepl("DMSO", Samples_24) ~ "DMSO"
    ),
    Species = case_when(
      grepl("_H$", Samples_24) ~ "H",
      grepl("_C$", Samples_24) ~ "C"
    ),
    Group = paste0(Stimulus, "_", Species),
    Ind_Num = as.numeric(gsub(".*_(\\d+)_.*", "\\1", Samples_24)),
    Indv_name = paste0("Ind", Ind_Num)
  ) %>%
  filter(!is.na(Ind_Num)) %>%
  mutate(
    Indv_name = factor(Indv_name, levels = ind_levels),
    Group = factor(Group, levels = group_levels),
    Stimulus = factor(Stimulus, levels = stim_levels)
  )

# --- Prepare gene summary from DE + logFC info ---
gene_summary <- de_specspec_all %>%
  filter(Stimulus %in% c("DOX", "NUTL")) %>%
  filter(DE_H == TRUE & DE_C == TRUE) %>%  # only genes DE in both species
  select(SYMBOL, Category, logFC_H, logFC_C)

# --- Pick genes ---
top_genes <- bind_rows(
  gene_summary %>%
    filter(Category == "Human-specific") %>%
    slice_max(order_by = logFC_H, n = 1),
  gene_summary %>%
    filter(Category == "Chimp-specific") %>%
    slice_max(order_by = logFC_C, n = 1),
  gene_summary %>%
    filter(Category == "Shared") %>%
    slice_sample(n = 15)
) %>%
  pull(SYMBOL)

# --- Filter plotting data ---
plot_data <- bp_long_ddr %>%
  filter(SYMBOL %in% top_genes)

# --- Plot each gene ---
for (gene in unique(plot_data$SYMBOL)) {
  gene_data <- plot_data %>% filter(SYMBOL == gene)
  gene_cat <- unique(gene_data$Category)
  
  p <- ggplot(gene_data, aes(x = Group, y = log2cpm, fill = Stimulus)) +
    geom_boxplot() +
    geom_point(aes(color = Indv_name), 
               size = 2, alpha = 0.7, 
               position = position_identity()) +
    scale_fill_manual(values = stim_col) +
    scale_color_manual(values = ind_col) +
    ggtitle(paste("log2cpm Expression ", gene, " - ", gene_cat)) +
    labs(x = "Condition", y = expression("log"[2]*"cpm")) +
    theme_custom()
  
  print(p)
}


```

```{r}
# --- Pick top genes per your criteria ---
top_genes <- bind_rows(
  gene_summary %>%
    filter(Category == "Human-specific", logFC_H > 0, logFC_C < 0) %>%
    slice_max(order_by = logFC_H, n = 1),
  
  gene_summary %>%
    filter(Category == "Chimp-specific", logFC_H < 0, logFC_C > 0) %>%
    slice_max(order_by = logFC_C, n = 1),
  
  gene_summary %>%
    filter(Category == "Shared") %>%
    slice_sample(n = 15)
) %>% pull(SYMBOL)

# --- Filter plotting data ---
plot_data <- bp_long_ddr %>%
  filter(SYMBOL %in% top_genes)

# --- Plot each gene with all stimuli but highlighting species-specific effect ---
for (gene in unique(plot_data$SYMBOL)) {
  gene_data <- plot_data %>% filter(SYMBOL == gene)
  gene_cat <- unique(gene_data$Category)
  
  p <- ggplot(gene_data, aes(x = Group, y = log2cpm, fill = Stimulus)) +
    geom_boxplot() +
    geom_point(aes(color = Indv_name), 
               size = 2, alpha = 0.7, 
               position = position_identity()) +
    scale_fill_manual(values = stim_col) +
    scale_color_manual(values = ind_col) +
    ggtitle(paste("log2cpm Expression ", gene, " - ", gene_cat)) +
    labs(x = "Condition", y = expression("log"[2]*"cpm")) +
    theme_custom()
  
  print(p)
}

```

```{r}
# ---- Define plotting parameters ----
ind_levels <- paste0("Ind", 1:14)
group_levels <- c("DOX_H", "NUTL_H", "DMSO_H",
                  "DOX_C", "NUTL_C", "DMSO_C")
stim_levels <- c("DOX", "NUTL", "DMSO")

# ---- Select genes ----
top_human <- de_specspec_all %>%
  filter(Category == "Human-specific", Stimulus == "DOX", DE_H == TRUE & DE_C == TRUE) %>%
  arrange(desc(logFC_H)) %>%
  slice_head(n = 1)

top_chimp <- de_specspec_all %>%
  filter(Category == "Chimp-specific", Stimulus == "DOX", DE_H == TRUE & DE_C == TRUE) %>%
  arrange(desc(logFC_C)) %>%
  slice_head(n = 1)

top_shared <- de_specspec_all %>%
  filter(Category == "Shared", Stimulus == "DOX", DE_H == TRUE & DE_C == TRUE) %>%
  slice_sample(n = 20)

selected_genes <- c(top_human$SYMBOL, top_chimp$SYMBOL, top_shared$SYMBOL)

# ---- Prepare plotting dataframe ----
plot_data <- bp_long_ddr %>%
  filter(SYMBOL %in% selected_genes,
         Stimulus %in% c("DOX", "NUTL", "DMSO")) %>%
  mutate(
    Indv_name = factor(Indv_name, levels = ind_levels),
    Group = factor(Group, levels = group_levels),
    Stimulus = factor(Stimulus, levels = stim_levels)
  )

# ---- Plot loop ----
for (gene in unique(plot_data$SYMBOL)) {
  gene_data <- plot_data %>% filter(SYMBOL == gene)
  gene_cat <- unique(gene_data$Category)
  
  p <- ggplot(gene_data, aes(x = Group, y = log2cpm, fill = Stimulus)) +
    geom_boxplot() +
    geom_point(aes(color = Indv_name), size = 2, alpha = 0.7,
               position = position_identity()) +
    scale_fill_manual(values = stim_col) +
    scale_color_manual(values = ind_col) +
    ggtitle(paste("log2CPM Expression:", gene, "-", gene_cat)) +
    labs(x = "Condition", y = expression("log"[2]*"CPM")) +
    theme_custom()
  
  print(p)
}

```


```{r}
# ---- Define plotting parameters ----
ind_levels <- paste0("Ind", 1:14)
group_levels <- c("DOX_H", "NUTL_H", "DMSO_H",
                  "DOX_C", "NUTL_C", "DMSO_C")
stim_levels <- c("DOX", "NUTL", "DMSO")

# ---- Summarize log2CPM by gene/species/stimulus ----
gene_summary <- bp_long_ddr %>%
  filter(Stimulus %in% c("DOX", "DMSO")) %>%
  group_by(SYMBOL, Category, Stimulus, Species) %>%
  summarise(mean_log2cpm = mean(log2cpm, na.rm = TRUE), .groups = "drop") %>%
  pivot_wider(names_from = c(Stimulus, Species), values_from = mean_log2cpm)  # columns: DOX_H, DOX_C, DMSO_H, DMSO_C

# ---- Select top 3 human-specific genes ----
top_human <- gene_summary %>%
  filter(Category == "Human-specific") %>%
  filter(DOX_H > DMSO_H & DOX_C < DMSO_C) %>%  # ensure opposite direction
  arrange(desc(DOX_H - DMSO_H)) %>%
  slice_head(n = 1)

# ---- Select top 3 chimp-specific genes ----
top_chimp <- gene_summary %>%
  filter(Category == "Chimp-specific") %>%
  filter(DOX_C > DMSO_C & DOX_H < DMSO_H) %>%  # ensure opposite direction
  arrange(desc(DOX_C - DMSO_C)) %>%
  slice_head(n = 1)

# ---- Select 3 random shared genes ----
top_shared <- gene_summary %>%
  filter(Category == "Shared") %>%
  filter((DOX_H - DMSO_H) * (DOX_C - DMSO_C) > 0) %>% # both up or both down
  slice_sample(n = 15)

selected_genes <- c(top_human$SYMBOL, top_chimp$SYMBOL, top_shared$SYMBOL)

# ---- Prepare plotting dataframe ----
plot_data <- bp_long_ddr %>%
  filter(SYMBOL %in% selected_genes,
         Stimulus %in% c("DOX", "NUTL", "DMSO")) %>%
  mutate(
    Indv_name = factor(Indv_name, levels = ind_levels),
    Group = factor(Group, levels = group_levels),
    Stimulus = factor(Stimulus, levels = stim_levels)
  )

# ---- Plot loop ----
for (gene in unique(plot_data$SYMBOL)) {
  gene_data <- plot_data %>% filter(SYMBOL == gene)
  gene_cat <- unique(gene_data$Category)
  
  p <- ggplot(gene_data, aes(x = Group, y = log2cpm, fill = Stimulus)) +
    geom_boxplot() +
    geom_point(aes(color = Indv_name), size = 2, alpha = 0.7,
               position = position_identity()) +
    scale_fill_manual(values = stim_col) +
    scale_color_manual(values = ind_col) +
    ggtitle(paste("log2CPM Expression:", gene, "-", gene_cat)) +
    labs(x = "Condition", y = expression("log"[2]*"CPM")) +
    theme_custom()
  
  print(p)
}

```

```{r}
# ---- Define plotting parameters ----
ind_levels <- paste0("Ind", 1:14)
group_levels <- c("DOX_H", "NUTL_H", "DMSO_H",
                  "DOX_C", "NUTL_C", "DMSO_C")
stim_levels <- c("DOX", "NUTL", "DMSO")

# ---- Summarize log2CPM by gene/species/stimulus ----
gene_summary <- bp_long_ddr %>%
  filter(Stimulus %in% c("DOX", "NUTL", "DMSO")) %>%
  group_by(SYMBOL, Category, Stimulus, Species) %>%
  summarise(mean_log2cpm = mean(log2cpm, na.rm = TRUE), .groups = "drop") %>%
  pivot_wider(names_from = c(Stimulus, Species), values_from = mean_log2cpm)
# Columns: DOX_H, DOX_C, NUTL_H, NUTL_C, DMSO_H, DMSO_C

# ---- Filter for opposite-direction DOX behavior ----
# Human-specific: DOX_H > DMSO_H and DOX_C < DMSO_C OR DOX_H < DMSO_H and DOX_C > DMSO_C
top_human <- gene_summary %>%
  filter(Category == "Human-specific") %>%
  filter((DOX_H - DMSO_H)*(DOX_C - DMSO_C) < 0) %>%  # opposite direction
  filter(abs(NUTL_H - DMSO_H) < 0.3 & abs(NUTL_C - DMSO_C) < 0.3) %>%
  arrange(desc(abs(DOX_H - DMSO_H))) %>%
  slice_head(n = 3)

# Chimp-specific: DOX_C > DMSO_C and DOX_H < DMSO_H OR DOX_C < DMSO_C and DOX_H > DMSO_H
top_chimp <- gene_summary %>%
  filter(Category == "Chimp-specific") %>%
  filter((DOX_H - DMSO_H)*(DOX_C - DMSO_C) < 0) %>%  # opposite direction
  filter(abs(NUTL_H - DMSO_H) < 0.3 & abs(NUTL_C - DMSO_C) < 0.3) %>%
  arrange(desc(abs(DOX_C - DMSO_C))) %>%
  slice_head(n = 3)

# Shared: pick random 3 genes
top_shared <- gene_summary %>%
  filter(Category == "Shared") %>%
  filter(abs(NUTL_H - DMSO_H) < 0.3 & abs(NUTL_C - DMSO_C) < 0.3) %>%
  slice_sample(n = 3)

selected_genes <- c(top_human$SYMBOL, top_chimp$SYMBOL, top_shared$SYMBOL)

# ---- Prepare plotting dataframe ----
plot_data <- bp_long_ddr %>%
  filter(SYMBOL %in% selected_genes,
         Stimulus %in% c("DOX", "NUTL", "DMSO")) %>%
  mutate(
    Indv_name = factor(Indv_name, levels = ind_levels),
    Group = factor(Group, levels = group_levels),
    Stimulus = factor(Stimulus, levels = stim_levels)
  )

# ---- Plot loop ----
for (gene in unique(plot_data$SYMBOL)) {
  gene_data <- plot_data %>% filter(SYMBOL == gene)
  gene_cat <- unique(gene_data$Category)
  
  p <- ggplot(gene_data, aes(x = Group, y = log2cpm, fill = Stimulus)) +
    geom_boxplot() +
    geom_point(aes(color = Indv_name), size = 2, alpha = 0.7,
               position = position_identity()) +
    scale_fill_manual(values = stim_col) +
    scale_color_manual(values = ind_col) +
    ggtitle(paste("log2CPM Expression:", gene, "-", gene_cat)) +
    labs(x = "Condition", y = expression("log"[2]*"CPM")) +
    theme_custom()
  
  print(p)
}

```

```{r}
# ---- 1. Identify candidate non-response genes ----
nonresponse_genes <- merged_df_24 %>%
  filter(!Category %in% c("Chimp-specific", "Human-specific", "Shared")) %>%
  distinct(Entrez_ID, SYMBOL, .keep_all = TRUE)

# ---- 1a. Subset based on DOX vs DMSO and NUTL vs DMSO consistency ----
# calculate max log2cpm difference between stimulus and DMSO per species
stable_genes <- bp_long_ddr %>%
  filter(SYMBOL %in% nonresponse_genes$SYMBOL) %>%
  filter(grepl("DOX|NUTL|DMSO", Samples_24)) %>%
  mutate(
    Stimulus = case_when(
      grepl("DOX", Samples_24) ~ "DOX",
      grepl("NUTL", Samples_24) ~ "NUTL",
      grepl("DMSO", Samples_24) ~ "DMSO"
    ),
    Species = case_when(
      grepl("_H$", Samples_24) ~ "H",
      grepl("_C$", Samples_24) ~ "C"
    )
  ) %>%
  group_by(SYMBOL, Species, Stimulus) %>%
  summarise(mean_log2cpm = mean(log2cpm, na.rm = TRUE), .groups = "drop") %>%
  pivot_wider(names_from = Stimulus, values_from = mean_log2cpm) %>%
  # keep only genes where DOX-DMSO and NUTL-DMSO differences are small (<0.5 log2CPM)
  filter(abs(DOX - DMSO) < 0.5, abs(NUTL - DMSO) < 0.5) %>%
  distinct(SYMBOL)

# ---- 1b. Sample top 15 just in case ----
nonresponse_genes_subset <- stable_genes %>% slice_sample(n = 20)

message("Selected ", nrow(nonresponse_genes_subset), " non-response genes.")

# ---- 2. Prepare long-format log2CPM data ----
bp_long_ddr <- bp_long_ddr %>%
  filter(grepl("DOX|NUTL|DMSO", Samples_24)) %>%
  mutate(
    Stimulus = case_when(
      grepl("DOX", Samples_24) ~ "DOX",
      grepl("NUTL", Samples_24) ~ "NUTL",
      grepl("DMSO", Samples_24) ~ "DMSO"
    ),
    Species = case_when(
      grepl("_H$", Samples_24) ~ "H",
      grepl("_C$", Samples_24) ~ "C"
    ),
    Group = paste0(Stimulus, "_", Species),
    Ind_Num = as.numeric(gsub(".*_(\\d+)_.*", "\\1", Samples_24)),
    Indv_name = paste0("Ind", Ind_Num)
  ) %>%
  filter(!is.na(Ind_Num)) %>%
  mutate(
    Indv_name = factor(Indv_name, levels = ind_levels),
    Group = factor(Group, levels = group_levels),
    Stimulus = factor(Stimulus, levels = stim_levels)
  )

# ---- 3. Join with selected genes ----
plot_data_nonresp <- bp_long_ddr %>%
  inner_join(nonresponse_genes_subset %>% select(SYMBOL), by = "SYMBOL")

# ---- 4. Plot each gene ----
for (gene in unique(plot_data_nonresp$SYMBOL)) {
  gene_data <- plot_data_nonresp %>% filter(SYMBOL == gene)
  
  p <- ggplot(gene_data, aes(x = Group, y = log2cpm, fill = Stimulus)) +
    geom_boxplot(outlier.shape = NA) +
    geom_point(aes(color = Indv_name),
               size = 2, alpha = 0.7,
               position = position_identity()) +
    scale_fill_manual(values = stim_col) +
    scale_color_manual(values = ind_col) +
    ggtitle(paste("Non-response gene:", gene)) +
    labs(x = "Condition", y = expression("log"[2]*"cpm")) +
    theme_custom()
  
  print(p)
}

```



```{r legend separate log2cpm boxplots}


 
example_gene <- unique(plot_data_nonresp$SYMBOL)[1]

ex_plot <- plot_data_nonresp %>%
  filter(SYMBOL == example_gene) %>%
  ggplot(aes(x = Group, y = log2cpm)) +
  geom_boxplot(aes(fill = Stimulus), outlier.shape = NA, alpha = 0.7) +
  geom_point(aes(color = Indv_name),
             size = 2, alpha = 0.8,
             position = position_jitter(width = 0.15)) +
  scale_fill_manual(values = stim_col, name = "Stimulus") +
  scale_color_manual(values = ind_col, name = "Individual") +
  labs(x = "Condition", y = expression("log"[2]*"CPM")) +
  theme_custom() +
  theme(
    legend.position = "right",
    legend.box = "vertical"
  )


shared_legend <- get_legend(explot)

legend_plot <- ggdraw(shared_legend)
ggsave(
  filename = file.path(output_folder, "Nonresponse_Legend.png"),
  plot = legend_plot,
  width = 5,
  height = 6
)



```


```{r Subset Genes of Interest log2cpm species specific}
# ---- 1. Define genes of interest ----
example_genes <- c("PPIP5K2")

#"ABCF3", "NCAPD2P1", "PER3", "CCDC93", "ZNF606-AS1", "LGI4", "RADIL", "SDHAF1", "AKAP17A", "RARG", "LPL", "MDM2", "LGALS3", "PELI2", "GPSM2", "SLC28A3", "RARG", "PELI2", "SLC28A3", "LRRTM4"

# ---- 2. Prepare data subset ----
plot_data_examples <- bp_long_ddr %>%
  filter(SYMBOL %in% example_genes)

# ---- 3. Plot each gene ----
for (gene in example_genes) {
  gene_data <- plot_data_examples %>% filter(SYMBOL == gene)
  
  p <- ggplot(gene_data, aes(x = Group, y = log2cpm, fill = Stimulus)) +
    geom_boxplot(outlier.shape = NA, linewidth = 0.5) +
    geom_point(aes(color = Indv_name),
               size = 1.25, alpha = 0.6,
               position = position_identity()) +
    scale_fill_manual(values = stim_col) +
    scale_color_manual(values = ind_col) +
    coord_cartesian(ylim = c(0, 10)) +
    ggtitle(gene) +
    labs(x = "Condition", y = expression("log"[2]*"CPM")) +
    theme_custom() +
    theme(
      plot.title = element_text(size = 10, face = "bold", hjust = 0.5),
      axis.title = element_text(size = 9),
      axis.text = element_text(size = 8),
      legend.text = element_text(size = 7),
      legend.title = element_text(size = 8)
    )
  
  # Print to view
  print(p)
  
  # Save to output folder
  filename_base <- paste0("ExampleGene_", gene, "_Boxplot")
  save_plot(plot = p,
            filename = filename_base,
            width = 5, height = 3,
            folder = output_folder)
}

```



```{r Simplified dataframe for species specific }
#make a function to find the opposite genes for all of my stimuli based on the above logFC scatterplots across species

adj_cutoff <- 0.05
stimuli <- readRDS("data/theme/stimuli_abbrv_list.RDS")

# ---- Function to process one stimulus ----
process_stimulus <- function(stim, toptable_list, adj_cutoff = 0.05) {
  species <- c("H", "C")
  
  # Extract tables
  extract_df <- function(stim, sp) {
    nm <- paste0("V.", stim, "24_", sp)
    if (!nm %in% names(toptable_list)) return(NULL)
    df <- toptable_list[[nm]] %>%
      dplyr::select(Entrez_ID, SYMBOL, 
                    logFC, adj.P.Val) %>%
      mutate(
        Entrez_ID = as.character(Entrez_ID),
        Condition = paste0(stim, "_", sp)
      )
    colnames(df)[3:4] <- paste0(c("logFC", 
                                  "adj.P.Val"), "_", sp)
    return(df)
  }
  
  df_H <- extract_df(stim, "H")
  df_C <- extract_df(stim, "C")
  
  if (is.null(df_H) | is.null(df_C)) return(NULL)
  
  # Merge H and C
  merged_df <- df_H %>%
    left_join(df_C, by = c("Entrez_ID", "SYMBOL"))
  
  # Mark DEGs
  merged_df <- merged_df %>%
    mutate(
      DEG_H = adj.P.Val_H < adj_cutoff,
      DEG_C = adj.P.Val_C < adj_cutoff,
      DEG_both = DEG_H & DEG_C
    )
  
  # Identify opposite-direction genes
  merged_df <- merged_df %>%
    mutate(
      OppositeDir = case_when(
        logFC_H > 0 & logFC_C < 0 ~ "Human-specific",
        logFC_H < 0 & logFC_C > 0 ~ "Chimp-specific",
        TRUE ~ NA_character_
      )
    )
  
  # Subset only true DEGs in both species and opposite-direction
  opposite_gene_df <- merged_df %>%
    filter(DEG_both, !is.na(OppositeDir)) %>%
    arrange(OppositeDir, desc(logFC_H))
  
  # Summary table
  sum_tab_specspec <- opposite_gene_df %>%
    group_by(OppositeDir) %>%
    summarise(
      n_genes = n(),
      .groups = "drop"
    ) %>%
    mutate(Total_genes = sum(n_genes))
  
  return(list(
    gene_df = opposite_gene_df,
    summary_table = sum_tab_specspec
  ))
}

# ---- Apply to all stimuli ----
results_list <- map(stimuli, ~ process_stimulus(.x, toptable_list_24, adj_cutoff))
names(results_list) <- stimuli


#save results
# saveRDS(sum_tab_specspec, "data/de/specspec/Summary_table_SpecSpecGenes_DEG.RDS")

# write.csv(sum_tab_specspec, "data/de/specspec/Summary_table_SpecSpecGenes_DEG.csv")

```

```{r DE NUTL Spec Spec gene}
nutl_results <- results_list[["NUTL"]]

# Filter for the gene that is "species-specific" but also DE in both species
species_specific_both_deg <- nutl_results %>%
  filter(Species_Specific %in% c("Human-specific", "Chimp-specific"),
         DEG_H == TRUE,
         DEG_C == TRUE)

# Show it
species_specific_both_deg

```

